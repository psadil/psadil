---
title: "Drawing a 3D Brain in plotly, showing the mesh"
format: hugo
jupyter: python3
author: Patrick Sadil
date: '2023-11-26'
slug: brain-mesh-3d-plotly
categories: [gist]
tags: [python]
subtitle: ''
summary: ''
authors: []
lastmod: '2022-10-23T22:59:09-04:00'
featured: no
projects: []
---

I've been experimenting with the 3D plotting capabilities of [nilearn](https://nilearn.github.io/stable/index.html), especially the [plotly engine](https://nilearn.github.io/stable/auto_examples/01_plotting/plot_3d_map_to_surface_projection.html#interactive-plotting-with-plotly). This engine produces interactive graphs that, but I've had some difficulty understanding how the meshes are produced. 

Information about the geometry format with MRI data is frustratingly difficult to find, but Noah Benson provides a helpful description [here](https://nben.net/MRI-Geometry/#surface-geometry-data). In particular, there are two key matrices: 

- an $n\times 3$ matrix of triangle vertices, where each row corresponds to the vertex's 3D coordinates, and
- an $m\times 3$ index matrix, where each row corresponds to a triangle face, and the elements are the three indices for the rows of the previous matrix.

When we make a plot in Nilearn, we get something like this.

```{python}

```

This is a nice clean surface, but where are the triangles?

The gist is to show one way of displaying the triangles on a surface mesh, building up from the raw plotly functions.

```{python}
from plotly import graph_objects as go

```

First, let's take a look at what we get from Nilearn when grab the data to be plotted.

```{python}
fsaverage = datasets.fetch_surf_fsaverage()
```


```{python}
coords, faces = surface.load_surf_mesh(fsaverage.infl_right)
x, y, z = coords.T
i, j, k = faces.T

pl_mesh = go.Mesh3d(
    x=coords[:, 0],
    y=coords[:, 1],
    z=coords[:, 2],
    i=faces[:, 0],
    j=faces[:, 1],
    k=faces[:, 2],
)

tri_points = coords[faces]
Xe = []
Ye = []
Ze = []
lines = []
for T in tri_points:
    Xe.extend([T[k % 3][0] for k in range(4)] + [None])
    Ye.extend([T[k % 3][1] for k in range(4)] + [None])
    Ze.extend([T[k % 3][2] for k in range(4)] + [None])

```

```{python}
fig = go.Figure(pl_mesh)
lines = go.Scatter3d(
    x=Xe,
    y=Ye,
    z=Ze,
    mode="lines",
    line=dict(color="black", width=2),
    showlegend=False,
)

fig.add_trace(lines)

```


It can also be interesting to add an roi


```{python}
destrieux_atlas = datasets.fetch_atlas_surf_destrieux()
parcellation = destrieux_atlas["map_right"]
roi = load_surf_data(parcellation)
parc_idx = np.where(roi == 28)[0]
```


```{python}
fig.add_traces(
    go.Scatter3d(
        x=coords[parc_idx, 0],
        y=coords[parc_idx, 1],
        z=coords[parc_idx, 2],
        mode="markers",
        showlegend=False,
    )
)
```