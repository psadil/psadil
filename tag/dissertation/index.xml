<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dissertation | psadil</title><link>https://psadil.github.io/psadil/tag/dissertation/</link><atom:link href="https://psadil.github.io/psadil/tag/dissertation/index.xml" rel="self" type="application/rss+xml"/><description>dissertation</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2021 Patrick Sadil</copyright><lastBuildDate>Sat, 14 Mar 2020 00:00:00 +0000</lastBuildDate><image><url>https://psadil.github.io/psadil/media/icon_hu3896c2ce465988ba1fc8077f9a6388c6_268630_512x512_fill_lanczos_center_2.png</url><title>dissertation</title><link>https://psadil.github.io/psadil/tag/dissertation/</link></image><item><title>counterbalanced continuous designs with eulerian walks</title><link>https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/</link><pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate><guid>https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/</guid><description>
&lt;script src="https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/index.en_files/header-attrs/header-attrs.js">&lt;/script>
&lt;script src="https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/index.en_files/htmlwidgets/htmlwidgets.js">&lt;/script>
&lt;script src="https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/index.en_files/viz/viz.js">&lt;/script>
&lt;link href="https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/index.en_files/DiagrammeR-styles/styles.css" rel="stylesheet" />
&lt;script src="https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/index.en_files/grViz-binding/grViz.js">&lt;/script>
&lt;p>Many experiments require counterbalancing sequences of trials. For example, I’m currently running an experiment on &lt;a href="https://psadil.github.io/psadil/post/serial-dependence/">serial dependence&lt;/a>&lt;a href="#fn1" class="footnote-ref" id="fnref1">&lt;sup>1&lt;/sup>&lt;/a>. In my experiment, participants report the orientation of a grating&lt;a href="#fn2" class="footnote-ref" id="fnref2">&lt;sup>2&lt;/sup>&lt;/a> stimulus on each trial. The serial dependence effect is how their responses on one trial depend on either the orientation of the previous trial or their response on that trial. To tease apart the effects of prior stimuli from prior responses, I’m manipulating the visual contrast of the gratings ( &lt;a href="https://en.wikipedia.org/wiki/Contrast_(vision)#Michelson_contrast">Michelson contrast&lt;/a> ). There are three levels of contrast: high, low, and zero (at zero contrast, there is no grating stimulus). This experiment will only need a few of the eight possible pairs of contrasts, and I’d like a sequence of trials that does not have any filler trials. So I need a flexible way to generate sequences of contrast.&lt;/p>
&lt;p>It turns out that this problem can be formulated as constructing an &lt;a href="https://en.wikipedia.org/wiki/Eulerian_path">Eulerian, directed cycle&lt;/a>. There are likely other ways &lt;a href="#fn3" class="footnote-ref" id="fnref3">&lt;sup>3&lt;/sup>&lt;/a>, but I think this is a neat approach. I won’t talk much about why any of this works, primarily because I don’t feel qualified to do so. However, the post includes a script that implements the algorithm, and checks that it has worked. So, hopefully it’ll be useful to at least a future me. But before discussing an Eulerian circuit, let’s talk about formulating the stimulus conditions as a graph.&lt;/p>
&lt;div id="trials-can-be-represented-with-a-graph" class="section level1">
&lt;h1>Trials can be represented with a graph&lt;/h1>
&lt;p>All potential sequences of trials will be represented as a graph. The graphs nodes will correspond to conditions, and edges between the nodes will correspond to allowable transitions. To represent these graphs, I’ll use the &lt;a href="http://visualizers.co/diagrammer/">&lt;code>DiagrammeR&lt;/code> package&lt;/a>.&lt;/p>
&lt;pre class="r">&lt;code># library(DiagrammeR)
library(magrittr)
# library(dplyr)&lt;/code>&lt;/pre>
&lt;p>In the graph of my experiment, there will be three nodes for each of the three conditions (Figure &lt;a href="#fig:nodes">1&lt;/a>).&lt;/p>
&lt;pre class="r">&lt;code>nodes &amp;lt;- DiagrammeR::create_node_df(
n = 3,
label = c(&amp;quot;zero&amp;quot;,&amp;quot;low&amp;quot;,&amp;quot;high&amp;quot;))
DiagrammeR::create_graph(nodes_df = nodes) %&amp;gt;%
DiagrammeR::render_graph(layout = &amp;quot;tree&amp;quot;)&lt;/code>&lt;/pre>
&lt;div class="figure">&lt;span id="fig:nodes">&lt;/span>
&lt;div id="htmlwidget-1" style="width:672px;height:480px;" class="grViz html-widget">&lt;/div>
&lt;script type="application/json" data-for="htmlwidget-1">{"x":{"diagram":"digraph {\n\ngraph [layout = \"neato\",\n outputorder = \"edgesfirst\",\n bgcolor = \"white\"]\n\nnode [fontname = \"Helvetica\",\n fontsize = \"10\",\n shape = \"circle\",\n fixedsize = \"true\",\n width = \"0.5\",\n style = \"filled\",\n fillcolor = \"aliceblue\",\n color = \"gray70\",\n fontcolor = \"gray50\"]\n\nedge [fontname = \"Helvetica\",\n fontsize = \"8\",\n len = \"1.5\",\n color = \"gray80\",\n arrowsize = \"0.5\"]\n\n \"1\" [label = \"zero\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0,1!\"] \n \"2\" [label = \"low\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"1,1!\"] \n \"3\" [label = \"high\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"2,1!\"] \n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}&lt;/script>
&lt;p class="caption">
Figure 1: Node represent experimental conditions.
&lt;/p>
&lt;/div>
&lt;p>In my experiment, I want trials to go from low to high, zero to high, or high to high, high to low, and high to zero (Figure &lt;a href="#fig:edges">2&lt;/a>). Including only these five types of transitions means excluding a few of the possible edges that could be in the graph. For example, I do not want any zero contrast trials to follow any other zero contrast trials, nor do I want a low contrast trial to follow a zero contrast trial.&lt;/p>
&lt;pre class="r">&lt;code>edges &amp;lt;- DiagrammeR::create_edge_df(
from = c(1,2,3,3,3),
to = c(3,3,3,1,2))
DiagrammeR::create_graph(
nodes_df = nodes,
edges_df = edges) %&amp;gt;%
DiagrammeR::render_graph(
layout = &amp;quot;tree&amp;quot;)&lt;/code>&lt;/pre>
&lt;div class="figure">&lt;span id="fig:edges">&lt;/span>
&lt;div id="htmlwidget-2" style="width:672px;height:480px;" class="grViz html-widget">&lt;/div>
&lt;script type="application/json" data-for="htmlwidget-2">{"x":{"diagram":"digraph {\n\ngraph [layout = \"neato\",\n outputorder = \"edgesfirst\",\n bgcolor = \"white\"]\n\nnode [fontname = \"Helvetica\",\n fontsize = \"10\",\n shape = \"circle\",\n fixedsize = \"true\",\n width = \"0.5\",\n style = \"filled\",\n fillcolor = \"aliceblue\",\n color = \"gray70\",\n fontcolor = \"gray50\"]\n\nedge [fontname = \"Helvetica\",\n fontsize = \"8\",\n len = \"1.5\",\n color = \"gray80\",\n arrowsize = \"0.5\"]\n\n \"1\" [label = \"zero\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0,2!\"] \n \"2\" [label = \"low\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"1,2!\"] \n \"3\" [label = \"high\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0.5,1!\"] \n \"1\"->\"3\" \n \"2\"->\"3\" \n \"3\"->\"3\" \n \"3\"->\"1\" \n \"3\"->\"2\" \n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}&lt;/script>
&lt;p class="caption">
Figure 2: Directed edges between nodes represent allowable transitions.
&lt;/p>
&lt;/div>
&lt;p>Constructing a sequence of trials will correspond to walking along the edges, from node to node. That walk will be Eulerian if each edge is be visited exactly once. With so few edges, it’s easy enough to visualize an Eulerian walk through the edges. One possible Eulerian walk (a cycle&lt;a href="#fn4" class="footnote-ref" id="fnref4">&lt;sup>4&lt;/sup>&lt;/a>, even) is shown in Figure &lt;a href="#fig:smallwalk">3&lt;/a>.&lt;/p>
&lt;pre class="r">&lt;code>edges_labelled &amp;lt;- DiagrammeR::create_edge_df(
from = c(3,2,3,3,1),
to = c(2,3,3,1,3),
label = as.character(1:5))
DiagrammeR::create_graph(
nodes_df = nodes,
edges_df = edges_labelled) %&amp;gt;%
DiagrammeR::render_graph(
layout = &amp;quot;tree&amp;quot;)&lt;/code>&lt;/pre>
&lt;div class="figure">&lt;span id="fig:smallwalk">&lt;/span>
&lt;div id="htmlwidget-3" style="width:672px;height:480px;" class="grViz html-widget">&lt;/div>
&lt;script type="application/json" data-for="htmlwidget-3">{"x":{"diagram":"digraph {\n\ngraph [layout = \"neato\",\n outputorder = \"edgesfirst\",\n bgcolor = \"white\"]\n\nnode [fontname = \"Helvetica\",\n fontsize = \"10\",\n shape = \"circle\",\n fixedsize = \"true\",\n width = \"0.5\",\n style = \"filled\",\n fillcolor = \"aliceblue\",\n color = \"gray70\",\n fontcolor = \"gray50\"]\n\nedge [fontname = \"Helvetica\",\n fontsize = \"8\",\n len = \"1.5\",\n color = \"gray80\",\n arrowsize = \"0.5\"]\n\n \"1\" [label = \"zero\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0,2!\"] \n \"2\" [label = \"low\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"1,2!\"] \n \"3\" [label = \"high\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0.5,1!\"] \n\"3\"->\"2\" [label = \"1\"] \n\"2\"->\"3\" [label = \"2\"] \n\"3\"->\"3\" [label = \"3\"] \n\"3\"->\"1\" [label = \"4\"] \n\"1\"->\"3\" [label = \"5\"] \n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}&lt;/script>
&lt;p class="caption">
Figure 3: The numbers trace an Eulerian cycle on this graph.
&lt;/p>
&lt;/div>
&lt;p>The cycle in Figure &lt;a href="#fig:smallwalk">3&lt;/a> implies a workable sequence of six trials, but the use of this Eulerian conceptualization will be how it automates creating much longer sequences. For example, to achieve 21 trials the edges could be replicated four times. Figure &lt;a href="#fig:messy">4&lt;/a> shows the graph with replicated edges, and already it looks too messy to traverse by sight. A real experiment will involve hundreds of trials, meaning that we’d like a way to automatically traverse an Eulerian circuit.&lt;/p>
&lt;pre class="r">&lt;code>edges_messy &amp;lt;- DiagrammeR::create_edge_df(
from = rep(c(3,2,3,3,1), each=4),
to = rep(c(2,3,3,1,3), each=4))
DiagrammeR::create_graph(
nodes_df = nodes,
edges_df = edges_messy) %&amp;gt;%
DiagrammeR::render_graph(layout = &amp;quot;tree&amp;quot;)&lt;/code>&lt;/pre>
&lt;div class="figure">&lt;span id="fig:messy">&lt;/span>
&lt;div id="htmlwidget-4" style="width:672px;height:480px;" class="grViz html-widget">&lt;/div>
&lt;script type="application/json" data-for="htmlwidget-4">{"x":{"diagram":"digraph {\n\ngraph [layout = \"neato\",\n outputorder = \"edgesfirst\",\n bgcolor = \"white\"]\n\nnode [fontname = \"Helvetica\",\n fontsize = \"10\",\n shape = \"circle\",\n fixedsize = \"true\",\n width = \"0.5\",\n style = \"filled\",\n fillcolor = \"aliceblue\",\n color = \"gray70\",\n fontcolor = \"gray50\"]\n\nedge [fontname = \"Helvetica\",\n fontsize = \"8\",\n len = \"1.5\",\n color = \"gray80\",\n arrowsize = \"0.5\"]\n\n \"1\" [label = \"zero\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0,2!\"] \n \"2\" [label = \"low\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"1,2!\"] \n \"3\" [label = \"high\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0.5,1!\"] \n \"3\"->\"2\" \n \"3\"->\"2\" \n \"3\"->\"2\" \n \"3\"->\"2\" \n \"2\"->\"3\" \n \"2\"->\"3\" \n \"2\"->\"3\" \n \"2\"->\"3\" \n \"3\"->\"3\" \n \"3\"->\"3\" \n \"3\"->\"3\" \n \"3\"->\"3\" \n \"3\"->\"1\" \n \"3\"->\"1\" \n \"3\"->\"1\" \n \"3\"->\"1\" \n \"1\"->\"3\" \n \"1\"->\"3\" \n \"1\"->\"3\" \n \"1\"->\"3\" \n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}&lt;/script>
&lt;p class="caption">
Figure 4: Replicating edges quickly complicates the graph.
&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="hierholzers-algorithm-automates-eulerian-cycles" class="section level1">
&lt;h1>Hierholzer’s algorithm automates Eulerian cycles&lt;/h1>
&lt;p>Fortunately, there exists and algorithm for making Eulerian cycles that is both simple to implement and quick to run. First, here is a helper function to replicate edges, &lt;code>replicate_edges&lt;/code>.&lt;/p>
&lt;pre class="r">&lt;code>#&amp;#39; replicate_edges
#&amp;#39;
#&amp;#39; @param edge_df output of DiagrammeR::create_edge_df (will only need columns `to` and `from`)
#&amp;#39; @param n_reps integer number of times that the edges should be replicated
#&amp;#39;
#&amp;#39; @return replicated edge dataframe
replicate_edges &amp;lt;- function(edge_df, n_reps){
replicate(n_reps, edge_df, simplify = FALSE) %&amp;gt;%
dplyr::bind_rows() %&amp;gt;%
dplyr::mutate(id = 1:dplyr::n())
}&lt;/code>&lt;/pre>
&lt;p>The next function will generate the Eulerian circuit, &lt;code>walk_circuit&lt;/code>. It will take in an edge dataframe (possibly replicated) and output a vector containing the nodes listed in the order that they were reached. Again, I won’t spend too long explaining why this works. But the basic idea is to traverse the edges, deleting edges as you walk along them. You’ll eventually reach a dead-end. If there are still more edges, then backtrack until you can travel along an edge that will result in a different dead-end. Save a list of the nodes that were traveled while backtracking, and these nodes will contain the circuit.&lt;/p>
&lt;pre class="r">&lt;code>#&amp;#39; walk_circuit
#&amp;#39;
#&amp;#39; @param edge_df edge dataframes
#&amp;#39; @param curr_v vertex at which to start the circuit
#&amp;#39;
#&amp;#39; @return vector consisting of Eulerian circuit along edges
#&amp;#39;
#&amp;#39; @details modified python script from https://gregorulm.com/finding-an-eulerian-path/.
walk_circuit &amp;lt;- function(edge_df, curr_v){
# helpful to have the edges stored by node
adj &amp;lt;- edge_df %&amp;gt;%
dplyr::group_split(from)
# vector to store final circuit
circuit &amp;lt;- c()
# Maintain a stack to keep vertices
# start from given node
curr_path &amp;lt;- curr_v
while (length(curr_path)){
# If there&amp;#39;s a remaining edge
if (nrow(adj[[curr_v]])){
# Push the vertex
curr_path &amp;lt;- c(curr_path,curr_v)
# Find the next vertex using an edge
next_v_ind &amp;lt;- sample.int(nrow(adj[[curr_v]]), size=1)
next_v &amp;lt;- adj[[curr_v]]$to[next_v_ind]
# and remove that edge
adj[[curr_v]] &amp;lt;- adj[[curr_v]][-next_v_ind,]
# Move to next vertex
curr_v &amp;lt;- next_v
} else{ # back-track to find remaining circuit
circuit &amp;lt;- c(circuit, curr_v)
# Back-tracking
curr_v &amp;lt;- tail(curr_path, n = 1)
curr_path &amp;lt;- head(curr_path, n = -1)
}
}
return(rev(circuit))
}&lt;/code>&lt;/pre>
&lt;p>Now replicate the edges twice and go for and Eulerian tour.&lt;/p>
&lt;pre class="r">&lt;code>edges_twice &amp;lt;- replicate_edges(edges, 2)
walk_circuit(edges_twice, 3)&lt;/code>&lt;/pre>
&lt;pre>&lt;code>## [1] 3 1 3 2 3 1 3 3 2 3 3&lt;/code>&lt;/pre>
&lt;p>This sequence is small enough that it’s feasible to verify the Eulerian property by hand, but it’ll be nice to have automate the checking. That is the purpose of this next function, &lt;code>check_blocking&lt;/code>.&lt;/p>
&lt;pre class="r">&lt;code>#&amp;#39; check_blocking
#&amp;#39;
#&amp;#39; @param circuit output of walk_circuit
#&amp;#39; @param nodes nodes_df, output of DiagrammeR::create_node_df. Used to label which nodes were visited during the walk
#&amp;#39;
#&amp;#39; @return tbl containing the counts of each transition type contained in the circuit.
#&amp;#39; If all went well, the counts should be equal
check_blocking &amp;lt;- function(circuit, nodes){
tibble::tibble(contrast = circuit, .name_repair = &amp;quot;check_unique&amp;quot;) %&amp;gt;%
dplyr::mutate(
trial = 1:dplyr::n(),
contrast = nodes$label[contrast],
last_contrast = dplyr::lag(contrast)) %&amp;gt;%
dplyr::filter(trial &amp;gt; 1) %&amp;gt;%
dplyr::group_by(contrast, last_contrast) %&amp;gt;%
dplyr::summarise(n = dplyr::n(), .groups = &amp;quot;drop&amp;quot;)
}&lt;/code>&lt;/pre>
&lt;p>Now, generate a sequence of 101 trials,&lt;/p>
&lt;pre class="r">&lt;code>edges_large &amp;lt;- replicate_edges(edges, n_reps = 20)
circuit &amp;lt;- walk_circuit(edges_large, 3)
circuit&lt;/code>&lt;/pre>
&lt;pre>&lt;code>## [1] 3 2 3 3 1 3 2 3 2 3 3 1 3 1 3 3 1 3 3 2 3 1 3 2 3 2 3 1 3 3 1 3 3 2 3 3 3
## [38] 1 3 1 3 1 3 3 2 3 2 3 3 2 3 2 3 1 3 1 3 3 2 3 1 3 1 3 3 2 3 1 3 3 3 3 3 2
## [75] 3 3 1 3 2 3 3 2 3 1 3 1 3 3 1 3 2 3 2 3 1 3 3 2 3 2 3&lt;/code>&lt;/pre>
&lt;p>and check that each transition happened equally often&lt;/p>
&lt;pre class="r">&lt;code>check_blocking(circuit, nodes) %&amp;gt;%
knitr::kable()&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th align="left">contrast&lt;/th>
&lt;th align="left">last_contrast&lt;/th>
&lt;th align="right">n&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td align="left">high&lt;/td>
&lt;td align="left">high&lt;/td>
&lt;td align="right">20&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td align="left">high&lt;/td>
&lt;td align="left">low&lt;/td>
&lt;td align="right">20&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td align="left">high&lt;/td>
&lt;td align="left">zero&lt;/td>
&lt;td align="right">20&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td align="left">low&lt;/td>
&lt;td align="left">high&lt;/td>
&lt;td align="right">20&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td align="left">zero&lt;/td>
&lt;td align="left">high&lt;/td>
&lt;td align="right">20&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;div class="footnotes">
&lt;hr />
&lt;ol>
&lt;li id="fn1">&lt;p>Well, I was running. Out of precaution for COVID-19, it currently seems like a bad idea to try to collect more participants. And UMass is closed for the rest of the semester.&lt;a href="#fnref1" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn2">&lt;p>adjacent black and white lines cropped to a circle, where the transitions between luminance follows a sinusoid&lt;a href="#fnref2" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn3">&lt;p>In this particular case, a simpler solution would be to assign each pair of contrasts a number. For example,&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>high -&amp;gt; high&lt;/li>
&lt;li>low -&amp;gt; high&lt;/li>
&lt;li>zero -&amp;gt; high&lt;/li>
&lt;/ol>
&lt;p>An appropriate sequence could be generated by simply permuting the numbers. For example 2, 3, 1, 3, 2 In that case, the sequence of trials would be &lt;code>low high zero high high high zero high low high&lt;/code>. This works because the second trial of each of the transitions are &lt;code>high&lt;/code>. But what if you also wanted a few &lt;code>low-&amp;gt;low&lt;/code> and &lt;code>zero-&amp;gt;zero&lt;/code> transitions, but wanted neither &lt;code>low-&amp;gt;zero&lt;/code> nor &lt;code>zero-&amp;gt;low&lt;/code>? By simply permuting the number codes, a &lt;code>zero-&amp;gt;zero&lt;/code> transition could appear right after a &lt;code>low-&amp;gt;low&lt;/code> transition, but to do that would require a filler &lt;code>low-zero&lt;/code>.&lt;a href="#fnref3" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn4">&lt;p>a cycle or circuit is a walk that starts and ends at the same node&lt;a href="#fnref4" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Circular Diffusion Model of Response Times</title><link>https://psadil.github.io/psadil/post/circular-diffusion-model-of-response-times/</link><pubDate>Thu, 12 Sep 2019 00:00:00 +0000</pubDate><guid>https://psadil.github.io/psadil/post/circular-diffusion-model-of-response-times/</guid><description>
&lt;script src="https://psadil.github.io/psadil/post/circular-diffusion-model-of-response-times/index.en_files/header-attrs/header-attrs.js">&lt;/script>
&lt;p>Many cognitive experiments involve asking participants to answer questions that require circular responses (Figure &lt;a href="#fig:color">1&lt;/a>). What was the color of the shape you just saw? In which direction was the arrow pointing? How tilted was the bar? The answers required by these questions differ fundamentally from the more common, categorical responses required to questions. Was the color green or red? Was the arrow pointing left or right? Was the bar tilted more than 45 degrees from vertical, between 45-90, or more than 90 degrees? In the continuous case, the experimenter looses the ability to classify responses as either correct or incorrect, and an analysis must consider participants’ degree of inaccuracy, their relative error. Circularity adds the additional complication that a response can only be erroneous up to a point; if a person responds that a vertical bar is 3 degrees offset from vertical on trial one and 359 degrees on trial two, the analysis must acknowledge that the average is close to truth. Although many models exist that describe how a participant will respond when the choice is binary, models of these are much more limited.&lt;/p>
&lt;div class="figure">&lt;span id="fig:color">&lt;/span>
&lt;img src="https://psadil.github.io/psadil/post/circular-diffusion-model-of-response-times/index.en_files/figure-html/color-1.png" alt="Cognitive experiments often require participants to provide a circularly continuous response. A participant might be asked to study shapes of different colors, hold the colors of every shape in memory, and then report on the one shape's color." width="672" />
&lt;p class="caption">
Figure 1: Cognitive experiments often require participants to provide a circularly continuous response. A participant might be asked to study shapes of different colors, hold the colors of every shape in memory, and then report on the one shape’s color.
&lt;/p>
&lt;/div>
&lt;p>&lt;span class="citation">&lt;a href="#ref-smith2016" role="doc-biblioref">Smith&lt;/a> (&lt;a href="#ref-smith2016" role="doc-biblioref">2016&lt;/a>)&lt;/span> present a new model of how participants provide circularly continuous responses, called the circular diffusion model. It is a model of the decision-making process, analyzing both the numerical value participants provided and how long it took them to provide a response. The model extends the drift diffusion model of binary decisions &lt;span class="citation">(&lt;a href="#ref-ratcliff1978" role="doc-biblioref">Ratcliff 1978&lt;/a>)&lt;/span>. Like the drift diffusion model, the circular diffusion model casts perceptual decisions as a stochastic process of evidence accumulation to a threshold; evidence is accumulated over time, and when enough evidence has been reached the process terminates in a motor behavior. The model is not concerned with how evidence accumulates, just that it does. In a working memory experiment, evidence might accumulate through repeated probes of memory. In a perceptual-decision task, each saccade might provide a different amount of evidence. In both cases, evidence grows at an average rate, and when there is enough evidence for a decision that decision is made. The amount of time required to reach that threshold of evidence is the response time. The circular diffusion model, therefore, proposes that the responses of rapid decisions which require circularly continuous responses can be modeled as a particle drifting in two dimensions out towards a circular boundary.&lt;/p>
&lt;div class="figure">&lt;span id="fig:cdm">&lt;/span>
&lt;img src="https://psadil.github.io/psadil/post/circular-diffusion-model-of-response-times/index.en_files/figure-html/cdm-1.gif" alt="A diffusing particle models perceptual decisions. In this example, wherever the particle first crosses the circle corresponds to the response, and the amount of time required to reach the edge is their response time." />
&lt;p class="caption">
Figure 2: A diffusing particle models perceptual decisions. In this example, wherever the particle first crosses the circle corresponds to the response, and the amount of time required to reach the edge is their response time.
&lt;/p>
&lt;/div>
&lt;p>Using the circular diffusion model affords researchers the same advantages conferred by using the standard drift diffusion model: the decision-making process can be decomposed into parameters of the model, and those parameters have psychologically meaningful values. For example, a participant might respond quickly, but that could either occur because they accumulate evidence rapidly or because they set a low threshold for evidence. There are three key parameters in the model: 1) the average direction the particle drifts (towards what decision are participants mostly accumulating evidence?), 2) the average rate at which the particle drifts (how quickly do participants accumulate evidence?), and 3) the radius of the circular boundary (how conservative are participants?). Estimating these parameters for participants across different conditions of an experiment enables the researcher to “measure” each of these psychological constructs given participants’ behavior.&lt;/p>
&lt;div id="references" class="section level1 unnumbered">
&lt;h1>References&lt;/h1>
&lt;div id="refs" class="references csl-bib-body hanging-indent">
&lt;div id="ref-ratcliff1978" class="csl-entry">
Ratcliff, Roger. 1978. &lt;span>“A Theory of Memory Retrieval.”&lt;/span> &lt;em>Psychological Review&lt;/em> 85 (2): 59. &lt;a href="https://doi.org/10.1037/0033-295X.85.2.59">https://doi.org/10.1037/0033-295X.85.2.59&lt;/a>.
&lt;/div>
&lt;div id="ref-smith2016" class="csl-entry">
Smith, Philip L. 2016. &lt;span>“Diffusion Theory of Decision Making in Continuous Report.”&lt;/span> &lt;em>Psychological Review&lt;/em> 123 (4): 425–51. &lt;a href="https://doi.org/10.1037/rev0000023">https://doi.org/10.1037/rev0000023&lt;/a>.
&lt;/div>
&lt;/div>
&lt;/div></description></item></channel></rss>