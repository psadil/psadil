<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>eyelink | psadil</title><link>https://psadil.github.io/psadil/tag/eyelink/</link><atom:link href="https://psadil.github.io/psadil/tag/eyelink/index.xml" rel="self" type="application/rss+xml"/><description>eyelink</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2025 Patrick Sadil</copyright><lastBuildDate>Sat, 25 May 2019 00:00:00 +0000</lastBuildDate><image><url>https://psadil.github.io/psadil/media/icon_hu3896c2ce465988ba1fc8077f9a6388c6_268630_512x512_fill_lanczos_center_2.png</url><title>eyelink</title><link>https://psadil.github.io/psadil/tag/eyelink/</link></image><item><title>eyetracking with eyelink in psychtoolbox, now with oop</title><link>https://psadil.github.io/psadil/post/eyetracking-in-psychtoolbox-oop/</link><pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate><guid>https://psadil.github.io/psadil/post/eyetracking-in-psychtoolbox-oop/</guid><description>
&lt;script src="https://psadil.github.io/psadil/post/eyetracking-in-psychtoolbox-oop/index.en_files/header-attrs/header-attrs.js">&lt;/script>
&lt;p>I’ve started trying out &lt;a href="https://www.mathworks.com/discovery/object-oriented-programming.html">MATLAB’s OOP&lt;/a> after mounting suspicion that the way I’d been coding experiments basically involved making something that looked and behaved like an object–but did so in a convoluted and inefficient way. See this &lt;a href="https://psadil.github.io/psadil/post/eyetracking-init/">post on eyetracking with PTB&lt;/a> as proof.&lt;/p>
&lt;p>This post is brief, and is about as well thought out as a github gist/gitlab snippet.&lt;/p>
&lt;p>The two classes I’ll work with here is a Window class and a Tracker class. The window class has 3 methods. The first &lt;a href="https://www.mathworks.com/help/matlab/matlab_oop/class-constructor-methods.html">constructor&lt;/a> method exists just to create the object. The constructed object will have a few default properties of the class. The second method is open, which (can you guess?) calls the PTB functions to open an onscreen window. The open method is fancier than it needs to be for this post (note the PsychImaging configuration, and the optional debugLevel flag). The final window method is the &lt;a href="https://www.mathworks.com/help/matlab/matlab_oop/handle-class-destructors.html">desctructor&lt;/a>. The destructor method is one of the advantages of leaning on MATLAB’s OOP syntax. That method will get called whenever the Window object’s lifecycle has ended (which might happen from explicit deletion of the object, closing MATLAB, the object is no longer referenced in the call stack, etc).&lt;/p>
&lt;p>The second class is the Tracker class, which interfaces with Eyelink. The Window class is only present here because Eyelink needs an open window to run calibration. There are five Tracker methods, but they are either analogous to the Window objects methods (constructor, destructor) or were largely presented in the previous post.&lt;/p>
&lt;div id="window-object" class="section level2">
&lt;h2>Window Object&lt;/h2>
&lt;pre class="matlab">&lt;code>
classdef Window &amp;lt; handle
% Window handles opening and closing of screen
properties (Constant)
screenNumber = 0
% background color of screen
background = GrayIndex(Window.screenNumber)
end
properties
pointer
winRect
end
methods
function obj = Window()
end
function open(obj, skipsynctests, debuglevel)
PsychImaging(&amp;#39;PrepareConfiguration&amp;#39;);
PsychImaging(&amp;#39;AddTask&amp;#39;, &amp;#39;General&amp;#39;, &amp;#39;FloatingPoint16Bit&amp;#39;);
Screen(&amp;#39;Preference&amp;#39;, &amp;#39;SkipSyncTests&amp;#39;, skipsynctests);
switch debuglevel
% no debug. run as usual, without listening to keyboard input
% and also hiding the cursor
case 0
ListenChar(-1);
HideCursor;
[obj.pointer, obj.winRect] = ...
PsychImaging(&amp;#39;OpenWindow&amp;#39;, obj.screenNumber, obj.background);
% light debug: still open fullscreen window, but keep keyboard input
case 1
[obj.pointer, obj.winRect] = ...
PsychImaging(&amp;#39;OpenWindow&amp;#39;, obj.screenNumber, obj.background);
% full debug: only open transparent window
case 10
PsychDebugWindowConfiguration(0, .5)
[obj.pointer, obj.winRect] = ...
PsychImaging(&amp;#39;OpenWindow&amp;#39;, obj.screenNumber, obj.background);
end
% Turn on blendfunction for antialiasing of drawing dots
Screen(&amp;#39;BlendFunction&amp;#39;, obj.pointer, &amp;#39;GL_SRC_ALPHA&amp;#39;, &amp;#39;GL_ONE_MINUS_SRC_ALPHA&amp;#39;);
topPriorityLevel = MaxPriority(obj.pointer);
Priority(topPriorityLevel);
end
% will auto-close open windows and return keyboard control when
% this object is deleted
function delete(obj) %#ok&amp;lt;INUSD&amp;gt;
ListenChar(0);
Priority(0);
sca;
end
end
end
&lt;/code>&lt;/pre>
&lt;/div>
&lt;div id="tracker-object" class="section level2">
&lt;h2>Tracker Object&lt;/h2>
&lt;p>The tracker object will mostly do what it did in the &lt;a href="https://psadil.github.io/psadil/post/eyetracking-init/">previous post&lt;/a>. Same functionality, but the syntax is much cleaner than the heavy use of switch/case conditionals.&lt;/p>
&lt;pre class="matlab">&lt;code>classdef Tracker &amp;lt; handle
properties
% flag to be called in scripts which enable turning on or off the tracker
% in an experiment (e.g., when debug mode is on)
using_tracker logical = false
% name of the write. must follow eyelink conventions. alphanumeric only, no
% more than 8 characters
filename char = &amp;#39;&amp;#39;
% eyelink object structure. stores many relevant parameters
el
end
methods
function obj = Tracker(using_tracker, filename, window)
obj.using_tracker = using_tracker;
obj.filename = filename;
% run calibration for tracker (see method below)
calibrate(obj, window);
end
function calibrate(obj, window)
if obj.using_tracker
% Provide Eyelink with details about the graphics environment
% and perform some initializations. The information is returned
% in a structure that also contains useful defaults
% and control codes (e.g. tracker state bit and Eyelink key values).
obj.el = EyelinkInitDefaults(window.pointer);
if ~EyelinkInit(0, 1)
error(&amp;#39;\n Eyelink Init aborted \n&amp;#39;);
end
%Reduce FOV for calibration and validation. Helpful when the
% the stimulus is only in the center of the screen, or at places
% like the fMRI scanner at UMass where the eyes have a lot in front
% of them
Eyelink(&amp;#39;Command&amp;#39;,&amp;#39;calibration_area_proportion = 0.5 0.5&amp;#39;);
Eyelink(&amp;#39;Command&amp;#39;,&amp;#39;validation_area_proportion = 0.5 0.5&amp;#39;);
% open file to record data to
status = Eyelink(&amp;#39;Openfile&amp;#39;, obj.filename);
if status ~= 0
error(&amp;#39;\n Eyelink Init aborted \n&amp;#39;);
end
% Setting the proper recording resolution, proper calibration type,
% as well as the data file content;
Eyelink(&amp;#39;Command&amp;#39;,&amp;#39;screen_pixel_coords = %ld %ld %ld %ld&amp;#39;, 0, 0, window.winRect(3)-1, window.winRect(4)-1);
Eyelink(&amp;#39;message&amp;#39;, &amp;#39;DISPLAY_COORDS %ld %ld %ld %ld&amp;#39;, 0, 0, window.winRect(3)-1, window.winRect(4)-1);
% set calibration type to 5 point.
Eyelink(&amp;#39;Command&amp;#39;, &amp;#39;calibration_type = HV5&amp;#39;);
% set EDF file contents using the file_sample_data and
% file-event_filter commands
% set link data thtough link_sample_data and link_event_filter
Eyelink(&amp;#39;Command&amp;#39;, &amp;#39;file_event_filter = RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT&amp;#39;);
Eyelink(&amp;#39;Command&amp;#39;, &amp;#39;link_event_filter = RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT&amp;#39;);
% check the software version
% add &amp;quot;HTARGET&amp;quot; to record possible target data for EyeLink Remote
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;file_sample_data = RIGHT,GAZE,HREF,GAZERES,AREA,HTARGET,STATUS,INPUT&amp;#39;);
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;link_sample_data = RIGHT,GAZE,HREF,GAZERES,AREA,HTARGET,STATUS,INPUT&amp;#39;);
% make sure we&amp;#39;re still connected.
if Eyelink(&amp;#39;IsConnected&amp;#39;)~=1
error(&amp;#39;\n Eyelink Init aborted \n&amp;#39;);
end
% set sample rate in camera setup screen
Eyelink(&amp;#39;Command&amp;#39;, &amp;#39;sample_rate = %d&amp;#39;, 1000);
% opens up main calibration scheme
EyelinkDoTrackerSetup(obj.el);
end
end
function status = eyelink(obj, varargin)
% calls main Eyelink routines only when
% this tracker object property using_tracker==true.
status = [];
if obj.using_tracker
if nargin==2
% construct calls to eyelink that don&amp;#39;t output any
% status
if strcmp(varargin{1}, &amp;#39;StopRecording&amp;#39;) || ...
strcmp(varargin{1}, &amp;#39;Shutdown&amp;#39;) ||...
strcmp(varargin{1}, &amp;#39;SetOfflineMode&amp;#39;)
% magic happens here, where the variable argument input
% is expanded an repassed through to Eyelink()
Eyelink(varargin{:});
else
status = Eyelink(varargin{:});
end
% all calls to Eyelink that have more than two inputs (e.g., the
% name of a function with some parameters to that function) return
% some status
else
status = Eyelink(varargin{:});
end
end
end
% starts up the eyelink machine. call this once the start of each
% experiment. could modify function to also draw something special
% to the screen (e.g., a background image). this might be the kind
% of function to modify if you wanted to draw trial-by-trial material
% to the eyetracking computer
function startup(obj)
% Must be offline to draw to EyeLink screen
obj.eyelink(&amp;#39;SetOfflineMode&amp;#39;);
% clear tracker display and draw background img to host pc
obj.eyelink(&amp;#39;Command&amp;#39;, &amp;#39;clear_screen 0&amp;#39;);
% draw simple fixation cross as later reference
obj.eyelink(&amp;#39;command&amp;#39;, &amp;#39;draw_cross %d %d&amp;#39;, 1920/2, 1080/2);
% give image transfer time to finish
WaitSecs(0.1);
end
% destructor function will get called whenever tracker object is deleted (e.g.,
% this function is automatically called when MATLAB closes, meaning you can&amp;#39;t
% forget to close the file connection with the tracker computer).
function delete(obj)
% waitsecs occur because the filetransfer often takes a moment, and moving
% on too quickly will result in an error
% End of Experiment; close the file first
% close graphics window, close data file and shut down tracker
obj.eyelink(&amp;#39;StopRecording&amp;#39;);
WaitSecs(0.1); % Slack to let stop definitely happen
obj.eyelink(&amp;#39;SetOfflineMode&amp;#39;);
obj.eyelink(&amp;#39;CloseFile&amp;#39;);
WaitSecs(0.1);
obj.eyelink(&amp;#39;ReceiveFile&amp;#39;, obj.filename, fullfile(pwd,&amp;#39;events&amp;#39;), 1);
WaitSecs(0.2);
obj.eyelink(&amp;#39;Shutdown&amp;#39;);
end
end
end
&lt;/code>&lt;/pre>
&lt;/div>
&lt;div id="run-the-calibration-and-use-the-tracker" class="section level2">
&lt;h2>Run the calibration (and use the tracker)&lt;/h2>
&lt;p>Putting this together, the following script starts calibration, and outlines how this tracker could be used in an experiment.&lt;/p>
&lt;pre class="matlab">&lt;code>
%% input
% ------------------
skipsynctests = 2;
debuglevel = 0;
using_tracker = true;
%% setup
% ------------------
% boilerplate setup
PsychDefaultSetup(2);
% initialize window
window = Window();
% open that window
open(window, skipsynctests, debuglevel)
% Initialize tracker object
tracker = Tracker(using_tracker, &amp;#39;OOPDEMO.edf&amp;#39;, window);
% run calibration
tracker.startup();
% Let Eyelink know that the experiment starts now
tracker.eyelink(&amp;#39;message&amp;#39;, &amp;#39;SYNCTIME&amp;#39;);
%% Experiment/trial code
% ------------------
% note that we should not need to wait to start recording,
% given that the stimulus will always be drawn a bit later
% (determined by how often phase changes occur)
tracker.eyelink(&amp;#39;StartRecording&amp;#39;);
% trial/experiment happens here ...
tracker.eyelink(&amp;#39;StopRecording&amp;#39;);
% Wait moment to ensure that tracker is definitely finished with the last few samples
WaitSecs(0.001);
%% Cleanup
% ------------------
% closes connection to Eyelink system, saves file
delete(tracker);
% closes window, restores keyboard input
delete(window);
&lt;/code>&lt;/pre>
&lt;p>What’s nice about this syntax (as before) is that only very minimal changes are required you don’t want to call the Eyelink functions (e.g., if you’re testing on a computer that doesn’t have the Eyelink system connected, or you’re debugging other parts of the experiment). By changing just the input, the Eyelink functions won’t be called.&lt;/p>
&lt;pre class="matlab">&lt;code>
using_tracker = false;
% all the rest as above
% ...&lt;/code>&lt;/pre>
&lt;/div>
&lt;div id="summary" class="section level1">
&lt;h1>Summary&lt;/h1>
&lt;p>There’s not much to summarize because I haven’t explained much! Again, this post is largely just an attempt to revise what I now think is a poor implementation, presented in an earlier post.&lt;/p>
&lt;/div></description></item><item><title>eyetracking with eyelink in psychtoolbox</title><link>https://psadil.github.io/psadil/post/eyetracking-init/</link><pubDate>Tue, 05 Jun 2018 00:00:00 +0000</pubDate><guid>https://psadil.github.io/psadil/post/eyetracking-init/</guid><description>
&lt;script src="https://psadil.github.io/psadil/post/eyetracking-init/index.en_files/header-attrs/header-attrs.js">&lt;/script>
&lt;p>UPDATE: I now think that the examples I’ve presented here obscure the interface with Eyelink. Much cleaner to use MATLAB’s object oriented programming. This is covered in &lt;a href="https://psadil.github.io/psadil/post/eyetracking-in-psychtoolbox-oop/">another post&lt;/a>.&lt;/p>
&lt;p>This post is designed as minimal documentation for using the Eyelink software at the UMass Amherst &lt;a href="https://www.umass.edu/ials/hmrc">hMRC&lt;/a>. The goals are very modest&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>Provide sample &lt;a href="http://psychtoolbox.org">Psychtoolbox&lt;/a> (PTB) and MATLAB code for integrating eyelink&lt;/li>
&lt;li>Explain a few parameters that you might want to change in your experiment&lt;/li>
&lt;/ol>
&lt;p>The main audience includes members of the cMAP and CEMNL labs at UMass, but other users of the hMRC may also benefit. This post includes various lines of code throughout this post, but the full files can be downloaded from the links at the bottom. Many of those links are private and will only work if you are a member of one of those labs.&lt;/p>
&lt;p>NOTE: This post is not designed to be a full introduction to the Eyelink toolbox within PTB. I’m not qualified to give a detailed tutorial. These are just a few bits of code that I have found useful. But, my needs have so far been really simple (i.e., make a record of where the eyes were during each run so that runs can be discarded if fixations during that run deviate more than x degrees from the center of the screen). The main resource in this post is probably the collection of links in the next section.&lt;/p>
&lt;div id="background-links-installing-extra-software" class="section level1">
&lt;h1>Background links + installing extra software&lt;/h1>
&lt;p>You’ll need to download the Eyelink API provided by SR Research. To do that, register an account &lt;a href="https://www.sr-support.com">here&lt;/a>. Note that they moderate the accounts fairly heavily, so it may take 24 hrs+ for the registration to go though. Once you’re registered, you can download the developers kit API ( &lt;a href="https://www.sr-support.com/forum/downloads/eyelink-display-software/39-eyelink-developers-kit-for-windows-windows-display-software">Windows&lt;/a>, &lt;a href="https://www.sr-support.com/forum/downloads/eyelink-display-software/46-eyelink-developers-kit-for-linux-linux-display-software">Linux&lt;/a> ). You’ll need that kit to be able to call Eyelink functions from within matlab (otherwise you get an error about missing mex files whenever you search for help pages). Registering also gives access to a support forum.&lt;/p>
&lt;p>Before moving to the next session, it may make sense to look through their &lt;a href="https://www.sr-support.com/forum/downloads/manuals">manuals&lt;/a>. If you have access to our box folder, here’s a link to the relevant &lt;a href="https://umass.box.com/s/1nr9m302wqn5l2jd9kaf9guv8ngqa9wp">Eyelink II manual&lt;/a> and the &lt;a href="https://umass.box.com/s/n8ki3br7watw2niuangxxflj6ulpnk67q">Data Viewer&lt;/a>. The manuals are, well, manuals, but reading through them takes less time than their length might suggest. If you are not a member of our lab, you may be able to ask a member of the hMRC to share the manuals.&lt;/p>
&lt;p>Without a licensing key, the version of the data viewer that can be downloaded is more or less useless (but, &lt;a href="https://www.sr-support.com/forum/downloads/data-analysis/4557-eyelink-data-viewer?4434-EyeLink-Data-Viewer=">here it is&lt;/a>). Instead, for working with the data in R, see &lt;a href="https://github.com/jashubbard/edfR">edfR&lt;/a> and &lt;a href="https://github.com/jashubbard/itrackR">itrackR&lt;/a>. Note that these are only working on Mac and Linux. So, you may need to be working on the server to install / use those libraries. Alternatively, you can also read the edf files directly into matlab using &lt;a href="https://www.sr-support.com/forum/downloads/data-analysis/5446-edfmex-reading-edf-data-directly-into-matlab">EDFMEX&lt;/a>. However, I won’t be able to help much with using these packages, given that I only discovered them while writing this post.&lt;/p>
&lt;p>Kwan-Jin Jung wrote a technical note about the eyetracking system, &lt;a href="https://www.umass.edu/ials/sites/default/files/hmrc_tn_eye_monitoring_during_fmri_scan.pdf">see here&lt;/a>, and here’s the &lt;a href="https://www.sr-research.com/products/eyelink-1000-plus/#LongRangeMount">advertisement for our tracker&lt;/a>.&lt;/p>
&lt;/div>
&lt;div id="sec:init" class="section level1">
&lt;h1>Initializing Eyelink&lt;/h1>
&lt;p>This section walks through a function that initializes the eyelink system. The first step to interfacing with the Eyelink is to call the PTB command &lt;a href="https://web.archive.org/web/20171214112707/http://docs.psychtoolbox.org/EyelinkInitDefaults">&lt;code>EyelinkInitDefaults&lt;/code>&lt;/a>. This defines a struct with a number of default parameters, &lt;code>el&lt;/code> about how the eyetracker will operate. I generally don’t want all of those defaults, so the function below modifies them as needed. After the parameters in &lt;code>el&lt;/code> have been modified, this function calls &lt;a href="https://web.archive.org/web/20171214035622/http://docs.psychtoolbox.org/EyelinkUpdateDefaults">&lt;code>EyelinkUpdateDefaults(el)&lt;/code>&lt;/a> to indicate to inform the eyelink system that the parameters should change.&lt;/p>
&lt;p>The main other point of this function is to start the eyetracker calibration. That should be done at the start of each run.&lt;/p>
&lt;pre class="matlab">&lt;code>
function [el, exit_flag] = setupEyeTracker( tracker, window, constants )
% SET UP TRACKER CONFIGURATION. Main goal is to modify defaults set in EyelinkInitDefaults.
%{
REQUIRED INPUT:
tracker: string, either &amp;#39;none&amp;#39; or &amp;#39;T60&amp;#39;
window: struct containing at least the fields
window.background: background color (whatever was set during call to e.g., PsychImaging(&amp;#39;OpenWindow&amp;#39;, window.screenNumber, window.background))
window.white: numeric defining the color white for the open window (e.g., window.white = WhiteIndex(window.screenNumber);)
window.pointer: scalar pointing to main screen (e.g., [window.pointer, window.winRect] = PsychImaging(&amp;#39;OpenWindow&amp;#39;, ...
window.screenNumber,window.background);)
window.winRect; PsychRect defining size of main window (e.g., [window.pointer, window.winRect] = PsychImaging(&amp;#39;OpenWindow&amp;#39;, ...
window.screenNumber,window.background);)
constants: struct containing at least
constants.eyelink_data_fname: string defining eyetracking data to be saved. Cannot be longer than 8 characters (before file extention). File extension must be &amp;#39;.edf&amp;#39;. (e.g., constants.eyelink_data_fname = [&amp;#39;scan&amp;#39;, num2str(input.runnum, &amp;#39;%02d&amp;#39;), &amp;#39;.edf&amp;#39;];)
OUTPUT:
if tracker == &amp;#39;T60&amp;#39;
el: struct defining parameters that have been set up about the eyetracker (see EyelinkInitDefaults)
if tracker == &amp;#39;none&amp;#39;
el == []
exit_flag: string that can be used to check whether this function exited successfully
SIDE EFFECTS:
When tracker == &amp;#39;T60&amp;#39;, calibration is started
%}
%%
exit_flag = &amp;#39;OK&amp;#39;;
switch tracker
case &amp;#39;T60&amp;#39;
% Provide Eyelink with details about the graphics environment
% and perform some initializations. The information is returned
% in a structure that also contains useful defaults
% and control codes (e.g. tracker state bit and Eyelink key values).
el = EyelinkInitDefaults(window.pointer);
% overrride default gray background of eyelink, otherwise runs end
% up gray! also, probably best to calibrate with same colors of
% background / stimuli as participant will encounter
el.backgroundcolour = window.background;
el.foregroundcolour = window.white;
el.msgfontcolour = window.white;
el.imgtitlecolour = window.white;
el.calibrationtargetcolour=[window.white window.white window.white];
EyelinkUpdateDefaults(el);
if ~EyelinkInit(0, 1)
fprintf(&amp;#39;\n Eyelink Init aborted \n&amp;#39;);
exit_flag = &amp;#39;ESC&amp;#39;;
return;
end
%Reduce FOV
Eyelink(&amp;#39;command&amp;#39;,&amp;#39;calibration_area_proportion = 0.5 0.5&amp;#39;);
Eyelink(&amp;#39;command&amp;#39;,&amp;#39;validation_area_proportion = 0.48 0.48&amp;#39;);
% open file to record data to
i = Eyelink(&amp;#39;Openfile&amp;#39;, constants.eyelink_data_fname);
if i ~= 0
fprintf(&amp;#39;\n Cannot create EDF file \n&amp;#39;);
exit_flag = &amp;#39;ESC&amp;#39;;
return;
end
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;add_file_preamble_text &amp;#39;&amp;#39;Recorded by NAME OF EXPERIMENT&amp;#39;&amp;#39;&amp;#39;);
% Setting the proper recording resolution, proper calibration type,
% as well as the data file content;
Eyelink(&amp;#39;command&amp;#39;,&amp;#39;screen_pixel_coords = %ld %ld %ld %ld&amp;#39;, 0, 0, window.winRect(3)-1, window.winRect(4)-1);
Eyelink(&amp;#39;message&amp;#39;, &amp;#39;DISPLAY_COORDS %ld %ld %ld %ld&amp;#39;, 0, 0, window.winRect(3)-1, window.winRect(4)-1);
% set calibration type.
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;calibration_type = HV5&amp;#39;);
% set EDF file contents using the file_sample_data and
% file-event_filter commands
% set link data thtough link_sample_data and link_event_filter
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT&amp;#39;);
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT&amp;#39;);
% check the software version
% add &amp;quot;HTARGET&amp;quot; to record possible target data for EyeLink Remote
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;file_sample_data = LEFT,RIGHT,GAZE,HREF,GAZERES,AREA,HTARGET,STATUS,INPUT&amp;#39;);
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;link_sample_data = LEFT,RIGHT,GAZE,HREF,GAZERES,AREA,HTARGET,STATUS,INPUT&amp;#39;);
% make sure we&amp;#39;re still connected.
if Eyelink(&amp;#39;IsConnected&amp;#39;)~=1 &amp;amp;&amp;amp; input.dummymode == 0
exit_flag = &amp;#39;ESC&amp;#39;;
return;
end
% possible changes from EyelinkPictureCustomCalibration
% set sample rate in camera setup screen
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;sample_rate = %d&amp;#39;, 1000);
% Will call the calibration routine
EyelinkDoTrackerSetup(el);
case &amp;#39;none&amp;#39;
el = [];
end
end
&lt;/code>&lt;/pre>
&lt;p>Here are a few parts of that function that you will probably want to adapt for your experiment.&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>The various color arguments&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Eyelink changes the background color of whatever screen is open. So, these colors (e.g., &lt;code>el.backgroundcolour&lt;/code>) should match whatever background your stimuli will be displayed on.&lt;/li>
&lt;/ul>
&lt;ol start="2" style="list-style-type: decimal">
&lt;li>&lt;code>Eyelink('command','calibration_area_proportion = 0.5 0.5');&lt;/code> and &lt;code>Eyelink('command','validation_area_proportion = 0.48 0.48');&lt;/code>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>The setup at the scanner has a hard time tracking eyes that are fixating near the edges of the screen. The issue is bad enough that it can be almost impossible to calibrate the tracker when the calibration dots appear on the edges. I only really use the eyetracker to have a record confirming that participants were more-or-less fixating during a run, so good calibration at the edges isn’t important to me. For this reason, I reduce the size of the calibration.&lt;/li>
&lt;/ul>
&lt;ol start="3" style="list-style-type: decimal">
&lt;li>Related to 2: &lt;code>Eyelink('command', 'calibration_type = HV5');&lt;/code>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>This sets the calibration routine to only use 5 dots, rather than 9. Again, my needs are pretty simple and calibration can be challenging, so 5 seems good enough.&lt;/li>
&lt;/ul>
&lt;ol start="4" style="list-style-type: decimal">
&lt;li>Wrapping the function in a switch argument (e.g., &lt;code>tracker ==&lt;/code>)&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>See the next section for some of the logic in writing code with a switch statement or two that all depends on how an initial variable is set&lt;a href="#fn1" class="footnote-ref" id="fnref1">&lt;sup>1&lt;/sup>&lt;/a>.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div id="the-eyelink-functions" class="section level1">
&lt;h1>The Eyelink functions&lt;/h1>
&lt;p>In &lt;code>setupEyeTracker&lt;/code>, you may have noticed many calls that took the following format &lt;a href="https://web.archive.org/web/20171214045939/http://docs.psychtoolbox.org/Eyelink">&lt;code>Eyelink('dosomethingspecial');&lt;/code>&lt;/a>. Commands like these are PTB’s way of communicating with the Eyelink software.&lt;/p>
&lt;p>There are a few such functions that you’ll need to include to record any usable data. First, the function we defined above, &lt;code>setupEyeTracker&lt;/code>, called the function &lt;a href="https://web.archive.org/web/20171214112703/http://docs.psychtoolbox.org/EyelinkDoTrackerSetup">&lt;code>EyelinkDoTrackerSetup(el)&lt;/code>&lt;/a>. This is a function internal to PTB. It runs the calibration routine. So, you’ll want a call to &lt;code>[el, exitflag] = setupEyeTracker( input.tracker, window, constants );&lt;/code> somewhere early in your code. I rerun the calibration at the start of each experimental run.&lt;/p>
&lt;p>Next, the following commands make sure that you’ve turned on the eyetracker&lt;/p>
&lt;pre class="matlab">&lt;code>% Must be offline to draw to EyeLink screen
Eyelink(&amp;#39;Command&amp;#39;, &amp;#39;set_idle_mode&amp;#39;);
% clear tracker display
Eyelink(&amp;#39;Command&amp;#39;, &amp;#39;clear_screen 0&amp;#39;);
Eyelink(&amp;#39;StartRecording&amp;#39;);
% always wait a moment for recording to have definitely started
WaitSecs(0.1);&lt;/code>&lt;/pre>
&lt;p>Eyelink will save it’s files in a specialized format&lt;a href="#fn2" class="footnote-ref" id="fnref2">&lt;sup>2&lt;/sup>&lt;/a>. For that file, it’s useful to mark when the experiment has actually started. So, include a command like&lt;/p>
&lt;pre class="matlab">&lt;code>Eyelink(&amp;#39;message&amp;#39;, &amp;#39;SYNCTIME&amp;#39;);&lt;/code>&lt;/pre>
&lt;p>to mark the start. Since this will probably be run in the scanner, a sensible time to place that would be shortly after receiving the scanner trigger, but before the next flip.&lt;/p>
&lt;p>When you’re done with the experiment run &lt;a href="https://web.archive.org/web/20171214045939/http://docs.psychtoolbox.org/Eyelink">&lt;code>Eyelink('Command', 'set_idle_mode');&lt;/code>&lt;/a> before saving data. Here’s an example of a short routine to save the data. I’ve defined a variable &lt;code>constants.eyelink_data_fname&lt;/code> to be a string that ends in ‘.edf’. Note that the filename can be no longer than 8 characters and cannot contain any special characters (only digits and letters).&lt;/p>
&lt;pre class="matlab">&lt;code>% the Eyelink(&amp;#39;ReceiveFile&amp;#39;) function does not wait for the file
% transfer to complete so you must have the entire try loop
% surrounding the function to ensure complete transfer of the EDF.
try
fprintf(&amp;#39;Receiving data file &amp;#39;&amp;#39;%s&amp;#39;&amp;#39;\n&amp;#39;, constants.eyelink_data_fname );
status = eyetrackerFcn(&amp;#39;ReceiveFile&amp;#39;);
if status &amp;gt; 0
fprintf(&amp;#39;ReceiveFile status %d\n&amp;#39;, status);
end
if 2==exist(edfFile, &amp;#39;file&amp;#39;)
fprintf(&amp;#39;Data file &amp;#39;&amp;#39;%s&amp;#39;&amp;#39; can be found in &amp;#39;&amp;#39;%s&amp;#39;&amp;#39;\n&amp;#39;, constants.eyelink_data_fname, pwd );
end
catch
fprintf(&amp;#39;Problem receiving data file &amp;#39;&amp;#39;%s&amp;#39;&amp;#39;\n&amp;#39;, constants.eyelink_data_fname );
end
&lt;/code>&lt;/pre>
&lt;/div>
&lt;div id="sample-script" class="section level1">
&lt;h1>Sample script&lt;/h1>
&lt;p>Unfortunately, attempting to call these function from a computer that does not have Eyelink’s software installed will produce an error. This makes developing and testing an experimental script challenging, because if we litter our code with calls to &lt;a href="https://web.archive.org/web/20171214045939/http://docs.psychtoolbox.org/Eyelink">&lt;code>Eyelink(...)&lt;/code>&lt;/a>, then when we’re not at the scanner computer we need to comment out all of those lines. I have no faith that I’ll remember to uncomment all of these lines when I’m at the scanner each time, so when I’m writing code that calls these functions I place them in a wrapper. Credit goes to &lt;a href="https://people.umass.edu/whopper/">Will Hopper&lt;/a> for showing me this strategy when designing functions that receive input.&lt;/p>
&lt;p>The main idea is two wrap all calls to &lt;code>Eyelink(...)&lt;/code> with a function that starts like this&lt;/p>
&lt;pre class="matlab">&lt;code>
function eyelinkFcn = makeEyelinkFcn(handlerName)
valid_types = {&amp;#39;none&amp;#39;,&amp;#39;T60&amp;#39;};
assert(ismember(handlerName, valid_types),...
[&amp;#39;&amp;quot;handlerType&amp;quot; argument must be one of the following: &amp;#39; strjoin(valid_types,&amp;#39;, &amp;#39;)])
switch handlerName
case &amp;#39;T60&amp;#39;
eyelinkFcn = @T60;
case &amp;#39;none&amp;#39;
eyelinkFcn = @do_nothing;
end
% more code to follow
end
&lt;/code>&lt;/pre>
&lt;p>The outer function, &lt;code>makeEyelinkFcn&lt;/code> receives as input the variable &lt;code>handlerName&lt;/code>, which can be either &lt;code>none&lt;/code> or &lt;code>T60&lt;/code>. Depending on that variable, the output to eyelinkFcn is then a call to an anonymous function which implements the actual calls to Eyelink. When &lt;code>handlerName == 'T60'&lt;/code>, &lt;code>makeEyelinkFcn&lt;/code> returns a function that is going to try to call various &lt;code>Eyelink(...)&lt;/code> routines (shown below). But, when &lt;code>handlerName == 'none'&lt;/code> &lt;code>makeEyelinkFcn&lt;/code> will return a function that does nothing.&lt;/p>
&lt;p>This enables the writing of code that will call the eyelink functions when desired (e.g., when at the scanner), but calls to those functions can also be avoided when desired (by calling &lt;code>makeEyeLinkFcn('none')&lt;/code> instead of &lt;code>makeEyeLinkFcn('T60')&lt;/code>).&lt;/p>
&lt;pre class="matlab">&lt;code>
% ...
eyetrackerFcn = makeEyelinkFcn(input.tracker);
eyetrackerFcn(&amp;#39;message&amp;#39;, &amp;#39;SYNCTIME&amp;#39;);
% ...
&lt;/code>&lt;/pre>
&lt;p>So long as input.tracker is taking different values, there’s no need to comment or uncomment when I’m working on a computer that has or doesn’t have an eyelink hooked up&lt;a href="#fn3" class="footnote-ref" id="fnref3">&lt;sup>3&lt;/sup>&lt;/a>.&lt;/p>
&lt;p>The remainder of this script defines the local function &lt;code>T60&lt;/code>, which allows all of the necessary wrapping to the different &lt;code>Eyelink(...)&lt;/code> commands.&lt;/p>
&lt;pre class="matlab">&lt;code>
function eyelinkFcn = makeEyelinkFcn(handlerName)
valid_types = {&amp;#39;none&amp;#39;,&amp;#39;T60&amp;#39;};
assert(ismember(handlerName, valid_types),...
[&amp;#39;&amp;quot;handlerType&amp;quot; argument must be one of the following: &amp;#39; strjoin(valid_types,&amp;#39;, &amp;#39;)])
switch handlerName
case &amp;#39;T60&amp;#39;
eyelinkFcn = @T60;
case &amp;#39;none&amp;#39;
eyelinkFcn = @do_nothing;
end
function status = T60(varargin)
status = [];
switch varargin{1}
case &amp;#39;EyelinkDoDriftCorrection&amp;#39;
% Do a drift correction at the beginning of each trial
% Performing drift correction (checking) is optional for
% EyeLink 1000 eye trackers.
EyelinkDoDriftCorrection(varargin{2},[],[],0);
case &amp;#39;Command&amp;#39;
Eyelink(&amp;#39;Command&amp;#39;, varargin{2})
case &amp;#39;ImageTransfer&amp;#39;
%transfer image to host
transferimginfo = imfinfo(varargin{2});
[width, height] = Screen(&amp;#39;WindowSize&amp;#39;, 0);
% image file should be 24bit or 32bit b5itmap
% parameters of ImageTransfer:
% imagePath, xPosition, yPosition, width, height, trackerXPosition, trackerYPosition, xferoptions
transferStatus = Eyelink(&amp;#39;ImageTransfer&amp;#39;,transferimginfo.Filename,...
0, 0, transferimginfo.Width, transferimginfo.Height, ...
width/2-transferimginfo.Width/2 ,height/2-transferimginfo.Height/2, 1);
if transferStatus ~= 0
fprintf(&amp;#39;*****Image transfer Failed*****-------\n&amp;#39;);
end
case &amp;#39;StartRecording&amp;#39;
Eyelink(&amp;#39;StartRecording&amp;#39;);
case &amp;#39;Message&amp;#39;
if nargin == 2
Eyelink(&amp;#39;Message&amp;#39;, varargin{2});
elseif nargin == 3
Eyelink(&amp;#39;Message&amp;#39;, varargin{2}, varargin{3});
elseif nargin == 4
Eyelink(&amp;#39;Message&amp;#39;, varargin{2}, varargin{3}, varargin{4});
end
case &amp;#39;StopRecording&amp;#39;
Eyelink(&amp;#39;StopRecording&amp;#39;);
case &amp;#39;CloseFile&amp;#39;
Eyelink(&amp;#39;CloseFile&amp;#39;);
case &amp;#39;ReceiveFile&amp;#39;
Eyelink(&amp;#39;ReceiveFile&amp;#39;);
case &amp;#39;EyeAvailable&amp;#39;
status = Eyelink(&amp;#39;EyeAvailable&amp;#39;);
end
end
function do_nothing(varargin)
% do nothing with arguments
end
end
&lt;/code>&lt;/pre>
&lt;/div>
&lt;div id="extra-resourcess" class="section level1">
&lt;h1>Extra Resourcess&lt;/h1>
&lt;p>For examples of these methods in action, check out &lt;a href="https://github.com/psadil/VTF">an experiment on Voxel Tuning Functions&lt;/a>. In particular, see &lt;a href="https://github.com/psadil/VTF/blob/master/lib/PsychSetup/setupEyeTracker.m">setupEyeTracker&lt;/a>, &lt;a href="https://github.com/psadil/VTF/blob/master/lib/PsychEyelink/makeEyelinkFcn.m">makeEyelinkFcn&lt;/a>. That repository also has examples of using the value returned by &lt;code>makeEyelinkFcn&lt;/code> in &lt;a href="https://github.com/psadil/VTF/blob/master/lib/PsychTasks/runContrast.m">runContrast&lt;/a>. Note that the repository may change from time to time and might not match the code in this post exactly. To download the exact files defined above, see &lt;a href="https://psadil.github.io/psadil/files/matlab/setupEyeTracker.m">setupEyeTracker&lt;/a>, &lt;a href="https://psadil.github.io/psadil/files/matlab/makeEyelinkFcn.m">makeEyelinkFcn&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://link.springer.com/article/10.3758/BF03195489">Here’s the original publication&lt;/a> that introduced the Eyelink interface to PTB.&lt;/p>
&lt;p>Also, for inspiration about the cool experiments that can be run with Eyelink’s software, see the &lt;a href="https://github.com/kleinerm/Psychtoolbox-3/tree/master/Psychtoolbox/PsychHardware/EyelinkToolbox/EyelinkDemos">PTB Demos&lt;/a>. See a list of &lt;code>Eyelink&lt;/code> functions &lt;a href="http://psychtoolbox.org/docs/EyelinkToolbox">here&lt;/a>. You’ll need to look at this page if you want access to the help files for these commands on a computer without Eyelink installed.&lt;/p>
&lt;p>Finally, thanks to &lt;a href="https://www.umass.edu/pbs/people/ramiro-reyes">Ramiro&lt;/a> for sharing a PTB script that got me started with Eyelink.&lt;/p>
&lt;/div>
&lt;div class="footnotes">
&lt;hr />
&lt;ol>
&lt;li id="fn1">&lt;p>though, I’ve already broken some of the logic I outline in that section by having more than one function with a switch statement.&lt;a href="#fnref1" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn2">&lt;p>The options relating to saving data are for another post. It seems like you can do quite a lot with the Eyelink Data Viewer when various event tags have been set up properly (see &lt;a href="https://umass.box.com/s/n8ki3br7watw2niuangxxflj6ulpk67q">manual, on box&lt;/a> ), but my needs are so simple that I haven’t bothered digging too deeply.&lt;a href="#fnref2" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn3">&lt;p>Of course, a similar effect could be achieved by littering the experimental code with a bunch of &lt;code>if then else&lt;/code> statements. However, this method has the advantage of massively reducing the number of switch statements in the code. Fewer switch statements can be easier to follow and modify, because most of the effect of the &lt;code>input.tracker&lt;/code> variable can be localized to a single function (the definition of &lt;code>makeEyelinkFcn&lt;/code>)&lt;a href="#fnref3" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>