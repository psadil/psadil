<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>experiments | psadil</title><link>https://psadil.github.io/psadil/category/experiments/</link><atom:link href="https://psadil.github.io/psadil/category/experiments/index.xml" rel="self" type="application/rss+xml"/><description>experiments</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2023 Patrick Sadil</copyright><lastBuildDate>Sat, 14 Mar 2020 00:00:00 +0000</lastBuildDate><image><url>https://psadil.github.io/psadil/media/icon_hu3896c2ce465988ba1fc8077f9a6388c6_268630_512x512_fill_lanczos_center_2.png</url><title>experiments</title><link>https://psadil.github.io/psadil/category/experiments/</link></image><item><title>counterbalanced continuous designs with eulerian walks</title><link>https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/</link><pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate><guid>https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/</guid><description>
&lt;script src="https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/index.en_files/header-attrs/header-attrs.js">&lt;/script>
&lt;script src="https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/index.en_files/htmlwidgets/htmlwidgets.js">&lt;/script>
&lt;script src="https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/index.en_files/viz/viz.js">&lt;/script>
&lt;link href="https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/index.en_files/DiagrammeR-styles/styles.css" rel="stylesheet" />
&lt;script src="https://psadil.github.io/psadil/post/counterbalanced-continuous-designs-with-eulerian-walks/index.en_files/grViz-binding/grViz.js">&lt;/script>
&lt;p>Many experiments require counterbalancing sequences of trials. For example, I’m currently running an experiment on &lt;a href="https://psadil.github.io/psadil/post/serial-dependence/">serial dependence&lt;/a>&lt;a href="#fn1" class="footnote-ref" id="fnref1">&lt;sup>1&lt;/sup>&lt;/a>. In my experiment, participants report the orientation of a grating&lt;a href="#fn2" class="footnote-ref" id="fnref2">&lt;sup>2&lt;/sup>&lt;/a> stimulus on each trial. The serial dependence effect is how their responses on one trial depend on either the orientation of the previous trial or their response on that trial. To tease apart the effects of prior stimuli from prior responses, I’m manipulating the visual contrast of the gratings ( &lt;a href="https://en.wikipedia.org/wiki/Contrast_(vision)#Michelson_contrast">Michelson contrast&lt;/a> ). There are three levels of contrast: high, low, and zero (at zero contrast, there is no grating stimulus). This experiment will only need a few of the eight possible pairs of contrasts, and I’d like a sequence of trials that does not have any filler trials. So I need a flexible way to generate sequences of contrast.&lt;/p>
&lt;p>It turns out that this problem can be formulated as constructing an &lt;a href="https://en.wikipedia.org/wiki/Eulerian_path">Eulerian, directed cycle&lt;/a>. There are likely other ways &lt;a href="#fn3" class="footnote-ref" id="fnref3">&lt;sup>3&lt;/sup>&lt;/a>, but I think this is a neat approach. I won’t talk much about why any of this works, primarily because I don’t feel qualified to do so. However, the post includes a script that implements the algorithm, and checks that it has worked. So, hopefully it’ll be useful to at least a future me. But before discussing an Eulerian circuit, let’s talk about formulating the stimulus conditions as a graph.&lt;/p>
&lt;div id="trials-can-be-represented-with-a-graph" class="section level1">
&lt;h1>Trials can be represented with a graph&lt;/h1>
&lt;p>All potential sequences of trials will be represented as a graph. The graphs nodes will correspond to conditions, and edges between the nodes will correspond to allowable transitions. To represent these graphs, I’ll use the &lt;a href="http://visualizers.co/diagrammer/">&lt;code>DiagrammeR&lt;/code> package&lt;/a>.&lt;/p>
&lt;pre class="r">&lt;code># library(DiagrammeR)
library(magrittr)
# library(dplyr)&lt;/code>&lt;/pre>
&lt;p>In the graph of my experiment, there will be three nodes for each of the three conditions (Figure &lt;a href="#fig:nodes">1&lt;/a>).&lt;/p>
&lt;pre class="r">&lt;code>nodes &amp;lt;- DiagrammeR::create_node_df(
n = 3,
label = c(&amp;quot;zero&amp;quot;,&amp;quot;low&amp;quot;,&amp;quot;high&amp;quot;))
DiagrammeR::create_graph(nodes_df = nodes) %&amp;gt;%
DiagrammeR::render_graph(layout = &amp;quot;tree&amp;quot;)&lt;/code>&lt;/pre>
&lt;div class="figure">&lt;span id="fig:nodes">&lt;/span>
&lt;div id="htmlwidget-1" style="width:672px;height:480px;" class="grViz html-widget">&lt;/div>
&lt;script type="application/json" data-for="htmlwidget-1">{"x":{"diagram":"digraph {\n\ngraph [layout = \"neato\",\n outputorder = \"edgesfirst\",\n bgcolor = \"white\"]\n\nnode [fontname = \"Helvetica\",\n fontsize = \"10\",\n shape = \"circle\",\n fixedsize = \"true\",\n width = \"0.5\",\n style = \"filled\",\n fillcolor = \"aliceblue\",\n color = \"gray70\",\n fontcolor = \"gray50\"]\n\nedge [fontname = \"Helvetica\",\n fontsize = \"8\",\n len = \"1.5\",\n color = \"gray80\",\n arrowsize = \"0.5\"]\n\n \"1\" [label = \"zero\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0,1!\"] \n \"2\" [label = \"low\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"1,1!\"] \n \"3\" [label = \"high\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"2,1!\"] \n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}&lt;/script>
&lt;p class="caption">
Figure 1: Node represent experimental conditions.
&lt;/p>
&lt;/div>
&lt;p>In my experiment, I want trials to go from low to high, zero to high, or high to high, high to low, and high to zero (Figure &lt;a href="#fig:edges">2&lt;/a>). Including only these five types of transitions means excluding a few of the possible edges that could be in the graph. For example, I do not want any zero contrast trials to follow any other zero contrast trials, nor do I want a low contrast trial to follow a zero contrast trial.&lt;/p>
&lt;pre class="r">&lt;code>edges &amp;lt;- DiagrammeR::create_edge_df(
from = c(1,2,3,3,3),
to = c(3,3,3,1,2))
DiagrammeR::create_graph(
nodes_df = nodes,
edges_df = edges) %&amp;gt;%
DiagrammeR::render_graph(
layout = &amp;quot;tree&amp;quot;)&lt;/code>&lt;/pre>
&lt;div class="figure">&lt;span id="fig:edges">&lt;/span>
&lt;div id="htmlwidget-2" style="width:672px;height:480px;" class="grViz html-widget">&lt;/div>
&lt;script type="application/json" data-for="htmlwidget-2">{"x":{"diagram":"digraph {\n\ngraph [layout = \"neato\",\n outputorder = \"edgesfirst\",\n bgcolor = \"white\"]\n\nnode [fontname = \"Helvetica\",\n fontsize = \"10\",\n shape = \"circle\",\n fixedsize = \"true\",\n width = \"0.5\",\n style = \"filled\",\n fillcolor = \"aliceblue\",\n color = \"gray70\",\n fontcolor = \"gray50\"]\n\nedge [fontname = \"Helvetica\",\n fontsize = \"8\",\n len = \"1.5\",\n color = \"gray80\",\n arrowsize = \"0.5\"]\n\n \"1\" [label = \"zero\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0,2!\"] \n \"2\" [label = \"low\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"1,2!\"] \n \"3\" [label = \"high\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0.5,1!\"] \n \"1\"->\"3\" \n \"2\"->\"3\" \n \"3\"->\"3\" \n \"3\"->\"1\" \n \"3\"->\"2\" \n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}&lt;/script>
&lt;p class="caption">
Figure 2: Directed edges between nodes represent allowable transitions.
&lt;/p>
&lt;/div>
&lt;p>Constructing a sequence of trials will correspond to walking along the edges, from node to node. That walk will be Eulerian if each edge is be visited exactly once. With so few edges, it’s easy enough to visualize an Eulerian walk through the edges. One possible Eulerian walk (a cycle&lt;a href="#fn4" class="footnote-ref" id="fnref4">&lt;sup>4&lt;/sup>&lt;/a>, even) is shown in Figure &lt;a href="#fig:smallwalk">3&lt;/a>.&lt;/p>
&lt;pre class="r">&lt;code>edges_labelled &amp;lt;- DiagrammeR::create_edge_df(
from = c(3,2,3,3,1),
to = c(2,3,3,1,3),
label = as.character(1:5))
DiagrammeR::create_graph(
nodes_df = nodes,
edges_df = edges_labelled) %&amp;gt;%
DiagrammeR::render_graph(
layout = &amp;quot;tree&amp;quot;)&lt;/code>&lt;/pre>
&lt;div class="figure">&lt;span id="fig:smallwalk">&lt;/span>
&lt;div id="htmlwidget-3" style="width:672px;height:480px;" class="grViz html-widget">&lt;/div>
&lt;script type="application/json" data-for="htmlwidget-3">{"x":{"diagram":"digraph {\n\ngraph [layout = \"neato\",\n outputorder = \"edgesfirst\",\n bgcolor = \"white\"]\n\nnode [fontname = \"Helvetica\",\n fontsize = \"10\",\n shape = \"circle\",\n fixedsize = \"true\",\n width = \"0.5\",\n style = \"filled\",\n fillcolor = \"aliceblue\",\n color = \"gray70\",\n fontcolor = \"gray50\"]\n\nedge [fontname = \"Helvetica\",\n fontsize = \"8\",\n len = \"1.5\",\n color = \"gray80\",\n arrowsize = \"0.5\"]\n\n \"1\" [label = \"zero\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0,2!\"] \n \"2\" [label = \"low\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"1,2!\"] \n \"3\" [label = \"high\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0.5,1!\"] \n\"3\"->\"2\" [label = \"1\"] \n\"2\"->\"3\" [label = \"2\"] \n\"3\"->\"3\" [label = \"3\"] \n\"3\"->\"1\" [label = \"4\"] \n\"1\"->\"3\" [label = \"5\"] \n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}&lt;/script>
&lt;p class="caption">
Figure 3: The numbers trace an Eulerian cycle on this graph.
&lt;/p>
&lt;/div>
&lt;p>The cycle in Figure &lt;a href="#fig:smallwalk">3&lt;/a> implies a workable sequence of six trials, but the use of this Eulerian conceptualization will be how it automates creating much longer sequences. For example, to achieve 21 trials the edges could be replicated four times. Figure &lt;a href="#fig:messy">4&lt;/a> shows the graph with replicated edges, and already it looks too messy to traverse by sight. A real experiment will involve hundreds of trials, meaning that we’d like a way to automatically traverse an Eulerian circuit.&lt;/p>
&lt;pre class="r">&lt;code>edges_messy &amp;lt;- DiagrammeR::create_edge_df(
from = rep(c(3,2,3,3,1), each=4),
to = rep(c(2,3,3,1,3), each=4))
DiagrammeR::create_graph(
nodes_df = nodes,
edges_df = edges_messy) %&amp;gt;%
DiagrammeR::render_graph(layout = &amp;quot;tree&amp;quot;)&lt;/code>&lt;/pre>
&lt;div class="figure">&lt;span id="fig:messy">&lt;/span>
&lt;div id="htmlwidget-4" style="width:672px;height:480px;" class="grViz html-widget">&lt;/div>
&lt;script type="application/json" data-for="htmlwidget-4">{"x":{"diagram":"digraph {\n\ngraph [layout = \"neato\",\n outputorder = \"edgesfirst\",\n bgcolor = \"white\"]\n\nnode [fontname = \"Helvetica\",\n fontsize = \"10\",\n shape = \"circle\",\n fixedsize = \"true\",\n width = \"0.5\",\n style = \"filled\",\n fillcolor = \"aliceblue\",\n color = \"gray70\",\n fontcolor = \"gray50\"]\n\nedge [fontname = \"Helvetica\",\n fontsize = \"8\",\n len = \"1.5\",\n color = \"gray80\",\n arrowsize = \"0.5\"]\n\n \"1\" [label = \"zero\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0,2!\"] \n \"2\" [label = \"low\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"1,2!\"] \n \"3\" [label = \"high\", fillcolor = \"#F0F8FF\", fontcolor = \"#000000\", pos = \"0.5,1!\"] \n \"3\"->\"2\" \n \"3\"->\"2\" \n \"3\"->\"2\" \n \"3\"->\"2\" \n \"2\"->\"3\" \n \"2\"->\"3\" \n \"2\"->\"3\" \n \"2\"->\"3\" \n \"3\"->\"3\" \n \"3\"->\"3\" \n \"3\"->\"3\" \n \"3\"->\"3\" \n \"3\"->\"1\" \n \"3\"->\"1\" \n \"3\"->\"1\" \n \"3\"->\"1\" \n \"1\"->\"3\" \n \"1\"->\"3\" \n \"1\"->\"3\" \n \"1\"->\"3\" \n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}&lt;/script>
&lt;p class="caption">
Figure 4: Replicating edges quickly complicates the graph.
&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="hierholzers-algorithm-automates-eulerian-cycles" class="section level1">
&lt;h1>Hierholzer’s algorithm automates Eulerian cycles&lt;/h1>
&lt;p>Fortunately, there exists and algorithm for making Eulerian cycles that is both simple to implement and quick to run. First, here is a helper function to replicate edges, &lt;code>replicate_edges&lt;/code>.&lt;/p>
&lt;pre class="r">&lt;code>#&amp;#39; replicate_edges
#&amp;#39;
#&amp;#39; @param edge_df output of DiagrammeR::create_edge_df (will only need columns `to` and `from`)
#&amp;#39; @param n_reps integer number of times that the edges should be replicated
#&amp;#39;
#&amp;#39; @return replicated edge dataframe
replicate_edges &amp;lt;- function(edge_df, n_reps){
replicate(n_reps, edge_df, simplify = FALSE) %&amp;gt;%
dplyr::bind_rows() %&amp;gt;%
dplyr::mutate(id = 1:dplyr::n())
}&lt;/code>&lt;/pre>
&lt;p>The next function will generate the Eulerian circuit, &lt;code>walk_circuit&lt;/code>. It will take in an edge dataframe (possibly replicated) and output a vector containing the nodes listed in the order that they were reached. Again, I won’t spend too long explaining why this works. But the basic idea is to traverse the edges, deleting edges as you walk along them. You’ll eventually reach a dead-end. If there are still more edges, then backtrack until you can travel along an edge that will result in a different dead-end. Save a list of the nodes that were traveled while backtracking, and these nodes will contain the circuit.&lt;/p>
&lt;pre class="r">&lt;code>#&amp;#39; walk_circuit
#&amp;#39;
#&amp;#39; @param edge_df edge dataframes
#&amp;#39; @param curr_v vertex at which to start the circuit
#&amp;#39;
#&amp;#39; @return vector consisting of Eulerian circuit along edges
#&amp;#39;
#&amp;#39; @details modified python script from https://gregorulm.com/finding-an-eulerian-path/.
walk_circuit &amp;lt;- function(edge_df, curr_v){
# helpful to have the edges stored by node
adj &amp;lt;- edge_df %&amp;gt;%
dplyr::group_split(from)
# vector to store final circuit
circuit &amp;lt;- c()
# Maintain a stack to keep vertices
# start from given node
curr_path &amp;lt;- curr_v
while (length(curr_path)){
# If there&amp;#39;s a remaining edge
if (nrow(adj[[curr_v]])){
# Push the vertex
curr_path &amp;lt;- c(curr_path,curr_v)
# Find the next vertex using an edge
next_v_ind &amp;lt;- sample.int(nrow(adj[[curr_v]]), size=1)
next_v &amp;lt;- adj[[curr_v]]$to[next_v_ind]
# and remove that edge
adj[[curr_v]] &amp;lt;- adj[[curr_v]][-next_v_ind,]
# Move to next vertex
curr_v &amp;lt;- next_v
} else{ # back-track to find remaining circuit
circuit &amp;lt;- c(circuit, curr_v)
# Back-tracking
curr_v &amp;lt;- tail(curr_path, n = 1)
curr_path &amp;lt;- head(curr_path, n = -1)
}
}
return(rev(circuit))
}&lt;/code>&lt;/pre>
&lt;p>Now replicate the edges twice and go for and Eulerian tour.&lt;/p>
&lt;pre class="r">&lt;code>edges_twice &amp;lt;- replicate_edges(edges, 2)
walk_circuit(edges_twice, 3)&lt;/code>&lt;/pre>
&lt;pre>&lt;code>## [1] 3 1 3 2 3 1 3 3 2 3 3&lt;/code>&lt;/pre>
&lt;p>This sequence is small enough that it’s feasible to verify the Eulerian property by hand, but it’ll be nice to have automate the checking. That is the purpose of this next function, &lt;code>check_blocking&lt;/code>.&lt;/p>
&lt;pre class="r">&lt;code>#&amp;#39; check_blocking
#&amp;#39;
#&amp;#39; @param circuit output of walk_circuit
#&amp;#39; @param nodes nodes_df, output of DiagrammeR::create_node_df. Used to label which nodes were visited during the walk
#&amp;#39;
#&amp;#39; @return tbl containing the counts of each transition type contained in the circuit.
#&amp;#39; If all went well, the counts should be equal
check_blocking &amp;lt;- function(circuit, nodes){
tibble::tibble(contrast = circuit, .name_repair = &amp;quot;check_unique&amp;quot;) %&amp;gt;%
dplyr::mutate(
trial = 1:dplyr::n(),
contrast = nodes$label[contrast],
last_contrast = dplyr::lag(contrast)) %&amp;gt;%
dplyr::filter(trial &amp;gt; 1) %&amp;gt;%
dplyr::group_by(contrast, last_contrast) %&amp;gt;%
dplyr::summarise(n = dplyr::n(), .groups = &amp;quot;drop&amp;quot;)
}&lt;/code>&lt;/pre>
&lt;p>Now, generate a sequence of 101 trials,&lt;/p>
&lt;pre class="r">&lt;code>edges_large &amp;lt;- replicate_edges(edges, n_reps = 20)
circuit &amp;lt;- walk_circuit(edges_large, 3)
circuit&lt;/code>&lt;/pre>
&lt;pre>&lt;code>## [1] 3 2 3 3 1 3 2 3 2 3 3 1 3 1 3 3 1 3 3 2 3 1 3 2 3 2 3 1 3 3 1 3 3 2 3 3 3
## [38] 1 3 1 3 1 3 3 2 3 2 3 3 2 3 2 3 1 3 1 3 3 2 3 1 3 1 3 3 2 3 1 3 3 3 3 3 2
## [75] 3 3 1 3 2 3 3 2 3 1 3 1 3 3 1 3 2 3 2 3 1 3 3 2 3 2 3&lt;/code>&lt;/pre>
&lt;p>and check that each transition happened equally often&lt;/p>
&lt;pre class="r">&lt;code>check_blocking(circuit, nodes) %&amp;gt;%
knitr::kable()&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th align="left">contrast&lt;/th>
&lt;th align="left">last_contrast&lt;/th>
&lt;th align="right">n&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td align="left">high&lt;/td>
&lt;td align="left">high&lt;/td>
&lt;td align="right">20&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td align="left">high&lt;/td>
&lt;td align="left">low&lt;/td>
&lt;td align="right">20&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td align="left">high&lt;/td>
&lt;td align="left">zero&lt;/td>
&lt;td align="right">20&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td align="left">low&lt;/td>
&lt;td align="left">high&lt;/td>
&lt;td align="right">20&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td align="left">zero&lt;/td>
&lt;td align="left">high&lt;/td>
&lt;td align="right">20&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;div class="footnotes">
&lt;hr />
&lt;ol>
&lt;li id="fn1">&lt;p>Well, I was running. Out of precaution for COVID-19, it currently seems like a bad idea to try to collect more participants. And UMass is closed for the rest of the semester.&lt;a href="#fnref1" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn2">&lt;p>adjacent black and white lines cropped to a circle, where the transitions between luminance follows a sinusoid&lt;a href="#fnref2" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn3">&lt;p>In this particular case, a simpler solution would be to assign each pair of contrasts a number. For example,&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>high -&amp;gt; high&lt;/li>
&lt;li>low -&amp;gt; high&lt;/li>
&lt;li>zero -&amp;gt; high&lt;/li>
&lt;/ol>
&lt;p>An appropriate sequence could be generated by simply permuting the numbers. For example 2, 3, 1, 3, 2 In that case, the sequence of trials would be &lt;code>low high zero high high high zero high low high&lt;/code>. This works because the second trial of each of the transitions are &lt;code>high&lt;/code>. But what if you also wanted a few &lt;code>low-&amp;gt;low&lt;/code> and &lt;code>zero-&amp;gt;zero&lt;/code> transitions, but wanted neither &lt;code>low-&amp;gt;zero&lt;/code> nor &lt;code>zero-&amp;gt;low&lt;/code>? By simply permuting the number codes, a &lt;code>zero-&amp;gt;zero&lt;/code> transition could appear right after a &lt;code>low-&amp;gt;low&lt;/code> transition, but to do that would require a filler &lt;code>low-zero&lt;/code>.&lt;a href="#fnref3" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn4">&lt;p>a cycle or circuit is a walk that starts and ends at the same node&lt;a href="#fnref4" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>eyetracking with eyelink in psychtoolbox, now with oop</title><link>https://psadil.github.io/psadil/post/eyetracking-in-psychtoolbox-oop/</link><pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate><guid>https://psadil.github.io/psadil/post/eyetracking-in-psychtoolbox-oop/</guid><description>
&lt;script src="https://psadil.github.io/psadil/post/eyetracking-in-psychtoolbox-oop/index.en_files/header-attrs/header-attrs.js">&lt;/script>
&lt;p>I’ve started trying out &lt;a href="https://www.mathworks.com/discovery/object-oriented-programming.html">MATLAB’s OOP&lt;/a> after mounting suspicion that the way I’d been coding experiments basically involved making something that looked and behaved like an object–but did so in a convoluted and inefficient way. See this &lt;a href="https://psadil.github.io/psadil/post/eyetracking-init/">post on eyetracking with PTB&lt;/a> as proof.&lt;/p>
&lt;p>This post is brief, and is about as well thought out as a github gist/gitlab snippet.&lt;/p>
&lt;p>The two classes I’ll work with here is a Window class and a Tracker class. The window class has 3 methods. The first &lt;a href="https://www.mathworks.com/help/matlab/matlab_oop/class-constructor-methods.html">constructor&lt;/a> method exists just to create the object. The constructed object will have a few default properties of the class. The second method is open, which (can you guess?) calls the PTB functions to open an onscreen window. The open method is fancier than it needs to be for this post (note the PsychImaging configuration, and the optional debugLevel flag). The final window method is the &lt;a href="https://www.mathworks.com/help/matlab/matlab_oop/handle-class-destructors.html">desctructor&lt;/a>. The destructor method is one of the advantages of leaning on MATLAB’s OOP syntax. That method will get called whenever the Window object’s lifecycle has ended (which might happen from explicit deletion of the object, closing MATLAB, the object is no longer referenced in the call stack, etc).&lt;/p>
&lt;p>The second class is the Tracker class, which interfaces with Eyelink. The Window class is only present here because Eyelink needs an open window to run calibration. There are five Tracker methods, but they are either analogous to the Window objects methods (constructor, destructor) or were largely presented in the previous post.&lt;/p>
&lt;div id="window-object" class="section level2">
&lt;h2>Window Object&lt;/h2>
&lt;pre class="matlab">&lt;code>
classdef Window &amp;lt; handle
% Window handles opening and closing of screen
properties (Constant)
screenNumber = 0
% background color of screen
background = GrayIndex(Window.screenNumber)
end
properties
pointer
winRect
end
methods
function obj = Window()
end
function open(obj, skipsynctests, debuglevel)
PsychImaging(&amp;#39;PrepareConfiguration&amp;#39;);
PsychImaging(&amp;#39;AddTask&amp;#39;, &amp;#39;General&amp;#39;, &amp;#39;FloatingPoint16Bit&amp;#39;);
Screen(&amp;#39;Preference&amp;#39;, &amp;#39;SkipSyncTests&amp;#39;, skipsynctests);
switch debuglevel
% no debug. run as usual, without listening to keyboard input
% and also hiding the cursor
case 0
ListenChar(-1);
HideCursor;
[obj.pointer, obj.winRect] = ...
PsychImaging(&amp;#39;OpenWindow&amp;#39;, obj.screenNumber, obj.background);
% light debug: still open fullscreen window, but keep keyboard input
case 1
[obj.pointer, obj.winRect] = ...
PsychImaging(&amp;#39;OpenWindow&amp;#39;, obj.screenNumber, obj.background);
% full debug: only open transparent window
case 10
PsychDebugWindowConfiguration(0, .5)
[obj.pointer, obj.winRect] = ...
PsychImaging(&amp;#39;OpenWindow&amp;#39;, obj.screenNumber, obj.background);
end
% Turn on blendfunction for antialiasing of drawing dots
Screen(&amp;#39;BlendFunction&amp;#39;, obj.pointer, &amp;#39;GL_SRC_ALPHA&amp;#39;, &amp;#39;GL_ONE_MINUS_SRC_ALPHA&amp;#39;);
topPriorityLevel = MaxPriority(obj.pointer);
Priority(topPriorityLevel);
end
% will auto-close open windows and return keyboard control when
% this object is deleted
function delete(obj) %#ok&amp;lt;INUSD&amp;gt;
ListenChar(0);
Priority(0);
sca;
end
end
end
&lt;/code>&lt;/pre>
&lt;/div>
&lt;div id="tracker-object" class="section level2">
&lt;h2>Tracker Object&lt;/h2>
&lt;p>The tracker object will mostly do what it did in the &lt;a href="https://psadil.github.io/psadil/post/eyetracking-init/">previous post&lt;/a>. Same functionality, but the syntax is much cleaner than the heavy use of switch/case conditionals.&lt;/p>
&lt;pre class="matlab">&lt;code>classdef Tracker &amp;lt; handle
properties
% flag to be called in scripts which enable turning on or off the tracker
% in an experiment (e.g., when debug mode is on)
using_tracker logical = false
% name of the write. must follow eyelink conventions. alphanumeric only, no
% more than 8 characters
filename char = &amp;#39;&amp;#39;
% eyelink object structure. stores many relevant parameters
el
end
methods
function obj = Tracker(using_tracker, filename, window)
obj.using_tracker = using_tracker;
obj.filename = filename;
% run calibration for tracker (see method below)
calibrate(obj, window);
end
function calibrate(obj, window)
if obj.using_tracker
% Provide Eyelink with details about the graphics environment
% and perform some initializations. The information is returned
% in a structure that also contains useful defaults
% and control codes (e.g. tracker state bit and Eyelink key values).
obj.el = EyelinkInitDefaults(window.pointer);
if ~EyelinkInit(0, 1)
error(&amp;#39;\n Eyelink Init aborted \n&amp;#39;);
end
%Reduce FOV for calibration and validation. Helpful when the
% the stimulus is only in the center of the screen, or at places
% like the fMRI scanner at UMass where the eyes have a lot in front
% of them
Eyelink(&amp;#39;Command&amp;#39;,&amp;#39;calibration_area_proportion = 0.5 0.5&amp;#39;);
Eyelink(&amp;#39;Command&amp;#39;,&amp;#39;validation_area_proportion = 0.5 0.5&amp;#39;);
% open file to record data to
status = Eyelink(&amp;#39;Openfile&amp;#39;, obj.filename);
if status ~= 0
error(&amp;#39;\n Eyelink Init aborted \n&amp;#39;);
end
% Setting the proper recording resolution, proper calibration type,
% as well as the data file content;
Eyelink(&amp;#39;Command&amp;#39;,&amp;#39;screen_pixel_coords = %ld %ld %ld %ld&amp;#39;, 0, 0, window.winRect(3)-1, window.winRect(4)-1);
Eyelink(&amp;#39;message&amp;#39;, &amp;#39;DISPLAY_COORDS %ld %ld %ld %ld&amp;#39;, 0, 0, window.winRect(3)-1, window.winRect(4)-1);
% set calibration type to 5 point.
Eyelink(&amp;#39;Command&amp;#39;, &amp;#39;calibration_type = HV5&amp;#39;);
% set EDF file contents using the file_sample_data and
% file-event_filter commands
% set link data thtough link_sample_data and link_event_filter
Eyelink(&amp;#39;Command&amp;#39;, &amp;#39;file_event_filter = RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT&amp;#39;);
Eyelink(&amp;#39;Command&amp;#39;, &amp;#39;link_event_filter = RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT&amp;#39;);
% check the software version
% add &amp;quot;HTARGET&amp;quot; to record possible target data for EyeLink Remote
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;file_sample_data = RIGHT,GAZE,HREF,GAZERES,AREA,HTARGET,STATUS,INPUT&amp;#39;);
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;link_sample_data = RIGHT,GAZE,HREF,GAZERES,AREA,HTARGET,STATUS,INPUT&amp;#39;);
% make sure we&amp;#39;re still connected.
if Eyelink(&amp;#39;IsConnected&amp;#39;)~=1
error(&amp;#39;\n Eyelink Init aborted \n&amp;#39;);
end
% set sample rate in camera setup screen
Eyelink(&amp;#39;Command&amp;#39;, &amp;#39;sample_rate = %d&amp;#39;, 1000);
% opens up main calibration scheme
EyelinkDoTrackerSetup(obj.el);
end
end
function status = eyelink(obj, varargin)
% calls main Eyelink routines only when
% this tracker object property using_tracker==true.
status = [];
if obj.using_tracker
if nargin==2
% construct calls to eyelink that don&amp;#39;t output any
% status
if strcmp(varargin{1}, &amp;#39;StopRecording&amp;#39;) || ...
strcmp(varargin{1}, &amp;#39;Shutdown&amp;#39;) ||...
strcmp(varargin{1}, &amp;#39;SetOfflineMode&amp;#39;)
% magic happens here, where the variable argument input
% is expanded an repassed through to Eyelink()
Eyelink(varargin{:});
else
status = Eyelink(varargin{:});
end
% all calls to Eyelink that have more than two inputs (e.g., the
% name of a function with some parameters to that function) return
% some status
else
status = Eyelink(varargin{:});
end
end
end
% starts up the eyelink machine. call this once the start of each
% experiment. could modify function to also draw something special
% to the screen (e.g., a background image). this might be the kind
% of function to modify if you wanted to draw trial-by-trial material
% to the eyetracking computer
function startup(obj)
% Must be offline to draw to EyeLink screen
obj.eyelink(&amp;#39;SetOfflineMode&amp;#39;);
% clear tracker display and draw background img to host pc
obj.eyelink(&amp;#39;Command&amp;#39;, &amp;#39;clear_screen 0&amp;#39;);
% draw simple fixation cross as later reference
obj.eyelink(&amp;#39;command&amp;#39;, &amp;#39;draw_cross %d %d&amp;#39;, 1920/2, 1080/2);
% give image transfer time to finish
WaitSecs(0.1);
end
% destructor function will get called whenever tracker object is deleted (e.g.,
% this function is automatically called when MATLAB closes, meaning you can&amp;#39;t
% forget to close the file connection with the tracker computer).
function delete(obj)
% waitsecs occur because the filetransfer often takes a moment, and moving
% on too quickly will result in an error
% End of Experiment; close the file first
% close graphics window, close data file and shut down tracker
obj.eyelink(&amp;#39;StopRecording&amp;#39;);
WaitSecs(0.1); % Slack to let stop definitely happen
obj.eyelink(&amp;#39;SetOfflineMode&amp;#39;);
obj.eyelink(&amp;#39;CloseFile&amp;#39;);
WaitSecs(0.1);
obj.eyelink(&amp;#39;ReceiveFile&amp;#39;, obj.filename, fullfile(pwd,&amp;#39;events&amp;#39;), 1);
WaitSecs(0.2);
obj.eyelink(&amp;#39;Shutdown&amp;#39;);
end
end
end
&lt;/code>&lt;/pre>
&lt;/div>
&lt;div id="run-the-calibration-and-use-the-tracker" class="section level2">
&lt;h2>Run the calibration (and use the tracker)&lt;/h2>
&lt;p>Putting this together, the following script starts calibration, and outlines how this tracker could be used in an experiment.&lt;/p>
&lt;pre class="matlab">&lt;code>
%% input
% ------------------
skipsynctests = 2;
debuglevel = 0;
using_tracker = true;
%% setup
% ------------------
% boilerplate setup
PsychDefaultSetup(2);
% initialize window
window = Window();
% open that window
open(window, skipsynctests, debuglevel)
% Initialize tracker object
tracker = Tracker(using_tracker, &amp;#39;OOPDEMO.edf&amp;#39;, window);
% run calibration
tracker.startup();
% Let Eyelink know that the experiment starts now
tracker.eyelink(&amp;#39;message&amp;#39;, &amp;#39;SYNCTIME&amp;#39;);
%% Experiment/trial code
% ------------------
% note that we should not need to wait to start recording,
% given that the stimulus will always be drawn a bit later
% (determined by how often phase changes occur)
tracker.eyelink(&amp;#39;StartRecording&amp;#39;);
% trial/experiment happens here ...
tracker.eyelink(&amp;#39;StopRecording&amp;#39;);
% Wait moment to ensure that tracker is definitely finished with the last few samples
WaitSecs(0.001);
%% Cleanup
% ------------------
% closes connection to Eyelink system, saves file
delete(tracker);
% closes window, restores keyboard input
delete(window);
&lt;/code>&lt;/pre>
&lt;p>What’s nice about this syntax (as before) is that only very minimal changes are required you don’t want to call the Eyelink functions (e.g., if you’re testing on a computer that doesn’t have the Eyelink system connected, or you’re debugging other parts of the experiment). By changing just the input, the Eyelink functions won’t be called.&lt;/p>
&lt;pre class="matlab">&lt;code>
using_tracker = false;
% all the rest as above
% ...&lt;/code>&lt;/pre>
&lt;/div>
&lt;div id="summary" class="section level1">
&lt;h1>Summary&lt;/h1>
&lt;p>There’s not much to summarize because I haven’t explained much! Again, this post is largely just an attempt to revise what I now think is a poor implementation, presented in an earlier post.&lt;/p>
&lt;/div></description></item><item><title>Anonymizing MTurk WorkerIDs</title><link>https://psadil.github.io/psadil/post/anonymizing-mtruk-worker-ids/</link><pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate><guid>https://psadil.github.io/psadil/post/anonymizing-mtruk-worker-ids/</guid><description>
&lt;script src="https://psadil.github.io/psadil/post/anonymizing-mtruk-worker-ids/index.en_files/header-attrs/header-attrs.js">&lt;/script>
&lt;p>It may be the case that Amazon Mechanical Turk WorkerIDs are not anonymous. &lt;a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2228728">Lease et al., 2013&lt;/a> describe at length how personally identifying information may be exposed when a researcher shares WorkerIDs. It is unclear to me the extent to which Amazon constructs their WorkerIDs at present, given that one of their striking demonstrations did not apply to my WorkerID. That is, they describe simply googling the WorkerID and receiving a picture of the participant, along with their full name. My WorkerID turn up nothing. Though, I have only been a worker on MTurk for a short while, so maybe I’ve been lucky and my ID has just not yet been shared widely.&lt;/p>
&lt;p>Regardless, providing extra anonymity to participants isn’t too much trouble. This post serves as documentation for a brief script that takes a sqlite database produced by running an experiment in jspsych + psiturk and replaces all instances of the WorkerID with a more secure code.&lt;/p>
&lt;p>The script relies on five R libraries&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>&lt;a href="https://magrittr.tidyverse.org">magrittr&lt;/a>, for ease of writing&lt;/li>
&lt;li>&lt;a href="https://dplyr.tidyverse.org">dplyr&lt;/a>, through (dbplyr)[cran.r-project.org/web/packages/dbplyr/vignettes/dbplyr.html], serves as the way to interface with the sqlite database&lt;/li>
&lt;li>&lt;a href="https://github.com/jeroen/openssl#readme">openssl&lt;/a> constructs a more secure identifier for each participant that can still be used to cross reference them across studies&lt;/li>
&lt;li>&lt;a href="https://stringr.tidyverse.org">stringr&lt;/a> does the work of replacing instances of the WorkerID with the more secure code&lt;/li>
&lt;li>&lt;a href="https://github.com/docopt/docopt.R">docopt&lt;/a>, wraps up the Rscript such that it can be called from the command line (in an environment in which Rscript is the name of a function. i.e., may be Rscript.exe in Windows powershell)&lt;/li>
&lt;/ol>
&lt;pre class="r">&lt;code>#!/usr/bin/env Rscript
# Anonymize participants database NOTE: always overrides the file --outfile
library(docopt)
doc &amp;lt;- &amp;quot;Usage:
anonymize_db.R [-i DBNAME] KEY OUTFILE
anonymize_db.R -h
Options:
-i --infile DBNAME sqlite database filename from which to read [default: participants_raw.db]
-t --table TABLE name of table within database to anonymize [default: participants]
-h --help show this help text
Arguments:
KEY key to salt WorkerIDs for extra security
OUTFILE sqlite database filename to write&amp;quot;
opt &amp;lt;- docopt(doc)
library(magrittr)
library(dplyr)
library(stringr)
library(openssl)
db &amp;lt;- dplyr::src_sqlite(opt$infile) %&amp;gt;%
dplyr::tbl(opt$table) %&amp;gt;%
dplyr::collect() %&amp;gt;%
dplyr::mutate(uniqueid = stringr::str_replace(uniqueid, workerid, openssl::sha256(workerid,
key = opt$KEY)), datastring = dplyr::case_when(is.na(datastring) ~ datastring,
TRUE ~ stringr::str_replace_all(datastring, workerid, openssl::sha256(workerid,
key = opt$KEY))), workerid = openssl::sha256(workerid, key = opt$KEY))
message(paste0(&amp;quot;read raw database: &amp;quot;, opt$infile))
con &amp;lt;- DBI::dbConnect(RSQLite::SQLite(), opt$OUTFILE)
dplyr::copy_to(con, db, opt$table, temporary = FALSE, indexes = list(&amp;quot;uniqueid&amp;quot;),
overwrite = TRUE)
DBI::dbDisconnect(con)
message(paste0(&amp;quot;wrote anonymized database: &amp;quot;, opt$OUTFILE))
message(paste0(&amp;quot;Store your KEY securely if you want the same WorkerIDs to create the same HMACs!&amp;quot;))&lt;/code>&lt;/pre>
&lt;p>As stated in the initial string of this script, a typical call might be&lt;/p>
&lt;p>&lt;code>anonymize_db.R longandsecurelystoredsalt participants.db&lt;/code>&lt;/p>
&lt;p>which will read in the sqlite database &lt;code>participants_raw.db&lt;/code> (default for –infile), convert all instances of WorkerID into a hash-digest with the sha256 algorithm, and store the result in a new sqlite database called &lt;code>participants.db&lt;/code>.&lt;/p>
&lt;p>The general workflow would be to include in your .gitignore the raw database output by psiturk. That way, the raw database is never uploaded into any repository. Then, when you are ready to host the experiment, you pull your repository as usual. As an extra step, you will now need to separately move around your raw database such that when you run the next experiment psiturk will know which workers have already participated. After collecting data, retrieve the database and run this anonymization script on it. The newly created database can then be bundled with your repository.&lt;/p>
&lt;p>This is a bit of extra work (i.e., you must manually send the database, retrieve the database, then anonymize it). However, the whole point is to avoid making it easy to download something with potentially identifying information.&lt;/p>
&lt;div id="gotchas" class="section level1">
&lt;h1>Gotchas&lt;/h1>
&lt;ol style="list-style-type: decimal">
&lt;li>&lt;p>This function will overwrite any database of the same name as OUTFILE. Though, that’s often not an issue. If you’ve anonymized a database (call the result &lt;code>participants.db&lt;/code>), added new participants to the same raw database, and then anonymize the raw database again, those participants that were anonymized in the first round will be re-anonymized and included in the new result.&lt;/p>&lt;/li>
&lt;li>&lt;p>If you want this function to convert a given WorkerID into a consistent code, you’ll need to call it with the same value for KEY.&lt;/p>&lt;/li>
&lt;li>&lt;p>It would be more secure to use a salt of random length for each participant separately.&lt;/p>&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>eyetracking with eyelink in psychtoolbox</title><link>https://psadil.github.io/psadil/post/eyetracking-init/</link><pubDate>Tue, 05 Jun 2018 00:00:00 +0000</pubDate><guid>https://psadil.github.io/psadil/post/eyetracking-init/</guid><description>
&lt;script src="https://psadil.github.io/psadil/post/eyetracking-init/index.en_files/header-attrs/header-attrs.js">&lt;/script>
&lt;p>UPDATE: I now think that the examples I’ve presented here obscure the interface with Eyelink. Much cleaner to use MATLAB’s object oriented programming. This is covered in &lt;a href="https://psadil.github.io/psadil/post/eyetracking-in-psychtoolbox-oop/">another post&lt;/a>.&lt;/p>
&lt;p>This post is designed as minimal documentation for using the Eyelink software at the UMass Amherst &lt;a href="https://www.umass.edu/ials/hmrc">hMRC&lt;/a>. The goals are very modest&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>Provide sample &lt;a href="http://psychtoolbox.org">Psychtoolbox&lt;/a> (PTB) and MATLAB code for integrating eyelink&lt;/li>
&lt;li>Explain a few parameters that you might want to change in your experiment&lt;/li>
&lt;/ol>
&lt;p>The main audience includes members of the cMAP and CEMNL labs at UMass, but other users of the hMRC may also benefit. This post includes various lines of code throughout this post, but the full files can be downloaded from the links at the bottom. Many of those links are private and will only work if you are a member of one of those labs.&lt;/p>
&lt;p>NOTE: This post is not designed to be a full introduction to the Eyelink toolbox within PTB. I’m not qualified to give a detailed tutorial. These are just a few bits of code that I have found useful. But, my needs have so far been really simple (i.e., make a record of where the eyes were during each run so that runs can be discarded if fixations during that run deviate more than x degrees from the center of the screen). The main resource in this post is probably the collection of links in the next section.&lt;/p>
&lt;div id="background-links-installing-extra-software" class="section level1">
&lt;h1>Background links + installing extra software&lt;/h1>
&lt;p>You’ll need to download the Eyelink API provided by SR Research. To do that, register an account &lt;a href="https://www.sr-support.com">here&lt;/a>. Note that they moderate the accounts fairly heavily, so it may take 24 hrs+ for the registration to go though. Once you’re registered, you can download the developers kit API ( &lt;a href="https://www.sr-support.com/forum/downloads/eyelink-display-software/39-eyelink-developers-kit-for-windows-windows-display-software">Windows&lt;/a>, &lt;a href="https://www.sr-support.com/forum/downloads/eyelink-display-software/46-eyelink-developers-kit-for-linux-linux-display-software">Linux&lt;/a> ). You’ll need that kit to be able to call Eyelink functions from within matlab (otherwise you get an error about missing mex files whenever you search for help pages). Registering also gives access to a support forum.&lt;/p>
&lt;p>Before moving to the next session, it may make sense to look through their &lt;a href="https://www.sr-support.com/forum/downloads/manuals">manuals&lt;/a>. If you have access to our box folder, here’s a link to the relevant &lt;a href="https://umass.box.com/s/1nr9m302wqn5l2jd9kaf9guv8ngqa9wp">Eyelink II manual&lt;/a> and the &lt;a href="https://umass.box.com/s/n8ki3br7watw2niuangxxflj6ulpnk67q">Data Viewer&lt;/a>. The manuals are, well, manuals, but reading through them takes less time than their length might suggest. If you are not a member of our lab, you may be able to ask a member of the hMRC to share the manuals.&lt;/p>
&lt;p>Without a licensing key, the version of the data viewer that can be downloaded is more or less useless (but, &lt;a href="https://www.sr-support.com/forum/downloads/data-analysis/4557-eyelink-data-viewer?4434-EyeLink-Data-Viewer=">here it is&lt;/a>). Instead, for working with the data in R, see &lt;a href="https://github.com/jashubbard/edfR">edfR&lt;/a> and &lt;a href="https://github.com/jashubbard/itrackR">itrackR&lt;/a>. Note that these are only working on Mac and Linux. So, you may need to be working on the server to install / use those libraries. Alternatively, you can also read the edf files directly into matlab using &lt;a href="https://www.sr-support.com/forum/downloads/data-analysis/5446-edfmex-reading-edf-data-directly-into-matlab">EDFMEX&lt;/a>. However, I won’t be able to help much with using these packages, given that I only discovered them while writing this post.&lt;/p>
&lt;p>Kwan-Jin Jung wrote a technical note about the eyetracking system, &lt;a href="https://www.umass.edu/ials/sites/default/files/hmrc_tn_eye_monitoring_during_fmri_scan.pdf">see here&lt;/a>, and here’s the &lt;a href="https://www.sr-research.com/products/eyelink-1000-plus/#LongRangeMount">advertisement for our tracker&lt;/a>.&lt;/p>
&lt;/div>
&lt;div id="sec:init" class="section level1">
&lt;h1>Initializing Eyelink&lt;/h1>
&lt;p>This section walks through a function that initializes the eyelink system. The first step to interfacing with the Eyelink is to call the PTB command &lt;a href="https://web.archive.org/web/20171214112707/http://docs.psychtoolbox.org/EyelinkInitDefaults">&lt;code>EyelinkInitDefaults&lt;/code>&lt;/a>. This defines a struct with a number of default parameters, &lt;code>el&lt;/code> about how the eyetracker will operate. I generally don’t want all of those defaults, so the function below modifies them as needed. After the parameters in &lt;code>el&lt;/code> have been modified, this function calls &lt;a href="https://web.archive.org/web/20171214035622/http://docs.psychtoolbox.org/EyelinkUpdateDefaults">&lt;code>EyelinkUpdateDefaults(el)&lt;/code>&lt;/a> to indicate to inform the eyelink system that the parameters should change.&lt;/p>
&lt;p>The main other point of this function is to start the eyetracker calibration. That should be done at the start of each run.&lt;/p>
&lt;pre class="matlab">&lt;code>
function [el, exit_flag] = setupEyeTracker( tracker, window, constants )
% SET UP TRACKER CONFIGURATION. Main goal is to modify defaults set in EyelinkInitDefaults.
%{
REQUIRED INPUT:
tracker: string, either &amp;#39;none&amp;#39; or &amp;#39;T60&amp;#39;
window: struct containing at least the fields
window.background: background color (whatever was set during call to e.g., PsychImaging(&amp;#39;OpenWindow&amp;#39;, window.screenNumber, window.background))
window.white: numeric defining the color white for the open window (e.g., window.white = WhiteIndex(window.screenNumber);)
window.pointer: scalar pointing to main screen (e.g., [window.pointer, window.winRect] = PsychImaging(&amp;#39;OpenWindow&amp;#39;, ...
window.screenNumber,window.background);)
window.winRect; PsychRect defining size of main window (e.g., [window.pointer, window.winRect] = PsychImaging(&amp;#39;OpenWindow&amp;#39;, ...
window.screenNumber,window.background);)
constants: struct containing at least
constants.eyelink_data_fname: string defining eyetracking data to be saved. Cannot be longer than 8 characters (before file extention). File extension must be &amp;#39;.edf&amp;#39;. (e.g., constants.eyelink_data_fname = [&amp;#39;scan&amp;#39;, num2str(input.runnum, &amp;#39;%02d&amp;#39;), &amp;#39;.edf&amp;#39;];)
OUTPUT:
if tracker == &amp;#39;T60&amp;#39;
el: struct defining parameters that have been set up about the eyetracker (see EyelinkInitDefaults)
if tracker == &amp;#39;none&amp;#39;
el == []
exit_flag: string that can be used to check whether this function exited successfully
SIDE EFFECTS:
When tracker == &amp;#39;T60&amp;#39;, calibration is started
%}
%%
exit_flag = &amp;#39;OK&amp;#39;;
switch tracker
case &amp;#39;T60&amp;#39;
% Provide Eyelink with details about the graphics environment
% and perform some initializations. The information is returned
% in a structure that also contains useful defaults
% and control codes (e.g. tracker state bit and Eyelink key values).
el = EyelinkInitDefaults(window.pointer);
% overrride default gray background of eyelink, otherwise runs end
% up gray! also, probably best to calibrate with same colors of
% background / stimuli as participant will encounter
el.backgroundcolour = window.background;
el.foregroundcolour = window.white;
el.msgfontcolour = window.white;
el.imgtitlecolour = window.white;
el.calibrationtargetcolour=[window.white window.white window.white];
EyelinkUpdateDefaults(el);
if ~EyelinkInit(0, 1)
fprintf(&amp;#39;\n Eyelink Init aborted \n&amp;#39;);
exit_flag = &amp;#39;ESC&amp;#39;;
return;
end
%Reduce FOV
Eyelink(&amp;#39;command&amp;#39;,&amp;#39;calibration_area_proportion = 0.5 0.5&amp;#39;);
Eyelink(&amp;#39;command&amp;#39;,&amp;#39;validation_area_proportion = 0.48 0.48&amp;#39;);
% open file to record data to
i = Eyelink(&amp;#39;Openfile&amp;#39;, constants.eyelink_data_fname);
if i ~= 0
fprintf(&amp;#39;\n Cannot create EDF file \n&amp;#39;);
exit_flag = &amp;#39;ESC&amp;#39;;
return;
end
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;add_file_preamble_text &amp;#39;&amp;#39;Recorded by NAME OF EXPERIMENT&amp;#39;&amp;#39;&amp;#39;);
% Setting the proper recording resolution, proper calibration type,
% as well as the data file content;
Eyelink(&amp;#39;command&amp;#39;,&amp;#39;screen_pixel_coords = %ld %ld %ld %ld&amp;#39;, 0, 0, window.winRect(3)-1, window.winRect(4)-1);
Eyelink(&amp;#39;message&amp;#39;, &amp;#39;DISPLAY_COORDS %ld %ld %ld %ld&amp;#39;, 0, 0, window.winRect(3)-1, window.winRect(4)-1);
% set calibration type.
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;calibration_type = HV5&amp;#39;);
% set EDF file contents using the file_sample_data and
% file-event_filter commands
% set link data thtough link_sample_data and link_event_filter
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT&amp;#39;);
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT&amp;#39;);
% check the software version
% add &amp;quot;HTARGET&amp;quot; to record possible target data for EyeLink Remote
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;file_sample_data = LEFT,RIGHT,GAZE,HREF,GAZERES,AREA,HTARGET,STATUS,INPUT&amp;#39;);
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;link_sample_data = LEFT,RIGHT,GAZE,HREF,GAZERES,AREA,HTARGET,STATUS,INPUT&amp;#39;);
% make sure we&amp;#39;re still connected.
if Eyelink(&amp;#39;IsConnected&amp;#39;)~=1 &amp;amp;&amp;amp; input.dummymode == 0
exit_flag = &amp;#39;ESC&amp;#39;;
return;
end
% possible changes from EyelinkPictureCustomCalibration
% set sample rate in camera setup screen
Eyelink(&amp;#39;command&amp;#39;, &amp;#39;sample_rate = %d&amp;#39;, 1000);
% Will call the calibration routine
EyelinkDoTrackerSetup(el);
case &amp;#39;none&amp;#39;
el = [];
end
end
&lt;/code>&lt;/pre>
&lt;p>Here are a few parts of that function that you will probably want to adapt for your experiment.&lt;/p>
&lt;ol style="list-style-type: decimal">
&lt;li>The various color arguments&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Eyelink changes the background color of whatever screen is open. So, these colors (e.g., &lt;code>el.backgroundcolour&lt;/code>) should match whatever background your stimuli will be displayed on.&lt;/li>
&lt;/ul>
&lt;ol start="2" style="list-style-type: decimal">
&lt;li>&lt;code>Eyelink('command','calibration_area_proportion = 0.5 0.5');&lt;/code> and &lt;code>Eyelink('command','validation_area_proportion = 0.48 0.48');&lt;/code>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>The setup at the scanner has a hard time tracking eyes that are fixating near the edges of the screen. The issue is bad enough that it can be almost impossible to calibrate the tracker when the calibration dots appear on the edges. I only really use the eyetracker to have a record confirming that participants were more-or-less fixating during a run, so good calibration at the edges isn’t important to me. For this reason, I reduce the size of the calibration.&lt;/li>
&lt;/ul>
&lt;ol start="3" style="list-style-type: decimal">
&lt;li>Related to 2: &lt;code>Eyelink('command', 'calibration_type = HV5');&lt;/code>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>This sets the calibration routine to only use 5 dots, rather than 9. Again, my needs are pretty simple and calibration can be challenging, so 5 seems good enough.&lt;/li>
&lt;/ul>
&lt;ol start="4" style="list-style-type: decimal">
&lt;li>Wrapping the function in a switch argument (e.g., &lt;code>tracker ==&lt;/code>)&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>See the next section for some of the logic in writing code with a switch statement or two that all depends on how an initial variable is set&lt;a href="#fn1" class="footnote-ref" id="fnref1">&lt;sup>1&lt;/sup>&lt;/a>.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div id="the-eyelink-functions" class="section level1">
&lt;h1>The Eyelink functions&lt;/h1>
&lt;p>In &lt;code>setupEyeTracker&lt;/code>, you may have noticed many calls that took the following format &lt;a href="https://web.archive.org/web/20171214045939/http://docs.psychtoolbox.org/Eyelink">&lt;code>Eyelink('dosomethingspecial');&lt;/code>&lt;/a>. Commands like these are PTB’s way of communicating with the Eyelink software.&lt;/p>
&lt;p>There are a few such functions that you’ll need to include to record any usable data. First, the function we defined above, &lt;code>setupEyeTracker&lt;/code>, called the function &lt;a href="https://web.archive.org/web/20171214112703/http://docs.psychtoolbox.org/EyelinkDoTrackerSetup">&lt;code>EyelinkDoTrackerSetup(el)&lt;/code>&lt;/a>. This is a function internal to PTB. It runs the calibration routine. So, you’ll want a call to &lt;code>[el, exitflag] = setupEyeTracker( input.tracker, window, constants );&lt;/code> somewhere early in your code. I rerun the calibration at the start of each experimental run.&lt;/p>
&lt;p>Next, the following commands make sure that you’ve turned on the eyetracker&lt;/p>
&lt;pre class="matlab">&lt;code>% Must be offline to draw to EyeLink screen
Eyelink(&amp;#39;Command&amp;#39;, &amp;#39;set_idle_mode&amp;#39;);
% clear tracker display
Eyelink(&amp;#39;Command&amp;#39;, &amp;#39;clear_screen 0&amp;#39;);
Eyelink(&amp;#39;StartRecording&amp;#39;);
% always wait a moment for recording to have definitely started
WaitSecs(0.1);&lt;/code>&lt;/pre>
&lt;p>Eyelink will save it’s files in a specialized format&lt;a href="#fn2" class="footnote-ref" id="fnref2">&lt;sup>2&lt;/sup>&lt;/a>. For that file, it’s useful to mark when the experiment has actually started. So, include a command like&lt;/p>
&lt;pre class="matlab">&lt;code>Eyelink(&amp;#39;message&amp;#39;, &amp;#39;SYNCTIME&amp;#39;);&lt;/code>&lt;/pre>
&lt;p>to mark the start. Since this will probably be run in the scanner, a sensible time to place that would be shortly after receiving the scanner trigger, but before the next flip.&lt;/p>
&lt;p>When you’re done with the experiment run &lt;a href="https://web.archive.org/web/20171214045939/http://docs.psychtoolbox.org/Eyelink">&lt;code>Eyelink('Command', 'set_idle_mode');&lt;/code>&lt;/a> before saving data. Here’s an example of a short routine to save the data. I’ve defined a variable &lt;code>constants.eyelink_data_fname&lt;/code> to be a string that ends in ‘.edf’. Note that the filename can be no longer than 8 characters and cannot contain any special characters (only digits and letters).&lt;/p>
&lt;pre class="matlab">&lt;code>% the Eyelink(&amp;#39;ReceiveFile&amp;#39;) function does not wait for the file
% transfer to complete so you must have the entire try loop
% surrounding the function to ensure complete transfer of the EDF.
try
fprintf(&amp;#39;Receiving data file &amp;#39;&amp;#39;%s&amp;#39;&amp;#39;\n&amp;#39;, constants.eyelink_data_fname );
status = eyetrackerFcn(&amp;#39;ReceiveFile&amp;#39;);
if status &amp;gt; 0
fprintf(&amp;#39;ReceiveFile status %d\n&amp;#39;, status);
end
if 2==exist(edfFile, &amp;#39;file&amp;#39;)
fprintf(&amp;#39;Data file &amp;#39;&amp;#39;%s&amp;#39;&amp;#39; can be found in &amp;#39;&amp;#39;%s&amp;#39;&amp;#39;\n&amp;#39;, constants.eyelink_data_fname, pwd );
end
catch
fprintf(&amp;#39;Problem receiving data file &amp;#39;&amp;#39;%s&amp;#39;&amp;#39;\n&amp;#39;, constants.eyelink_data_fname );
end
&lt;/code>&lt;/pre>
&lt;/div>
&lt;div id="sample-script" class="section level1">
&lt;h1>Sample script&lt;/h1>
&lt;p>Unfortunately, attempting to call these function from a computer that does not have Eyelink’s software installed will produce an error. This makes developing and testing an experimental script challenging, because if we litter our code with calls to &lt;a href="https://web.archive.org/web/20171214045939/http://docs.psychtoolbox.org/Eyelink">&lt;code>Eyelink(...)&lt;/code>&lt;/a>, then when we’re not at the scanner computer we need to comment out all of those lines. I have no faith that I’ll remember to uncomment all of these lines when I’m at the scanner each time, so when I’m writing code that calls these functions I place them in a wrapper. Credit goes to &lt;a href="https://people.umass.edu/whopper/">Will Hopper&lt;/a> for showing me this strategy when designing functions that receive input.&lt;/p>
&lt;p>The main idea is two wrap all calls to &lt;code>Eyelink(...)&lt;/code> with a function that starts like this&lt;/p>
&lt;pre class="matlab">&lt;code>
function eyelinkFcn = makeEyelinkFcn(handlerName)
valid_types = {&amp;#39;none&amp;#39;,&amp;#39;T60&amp;#39;};
assert(ismember(handlerName, valid_types),...
[&amp;#39;&amp;quot;handlerType&amp;quot; argument must be one of the following: &amp;#39; strjoin(valid_types,&amp;#39;, &amp;#39;)])
switch handlerName
case &amp;#39;T60&amp;#39;
eyelinkFcn = @T60;
case &amp;#39;none&amp;#39;
eyelinkFcn = @do_nothing;
end
% more code to follow
end
&lt;/code>&lt;/pre>
&lt;p>The outer function, &lt;code>makeEyelinkFcn&lt;/code> receives as input the variable &lt;code>handlerName&lt;/code>, which can be either &lt;code>none&lt;/code> or &lt;code>T60&lt;/code>. Depending on that variable, the output to eyelinkFcn is then a call to an anonymous function which implements the actual calls to Eyelink. When &lt;code>handlerName == 'T60'&lt;/code>, &lt;code>makeEyelinkFcn&lt;/code> returns a function that is going to try to call various &lt;code>Eyelink(...)&lt;/code> routines (shown below). But, when &lt;code>handlerName == 'none'&lt;/code> &lt;code>makeEyelinkFcn&lt;/code> will return a function that does nothing.&lt;/p>
&lt;p>This enables the writing of code that will call the eyelink functions when desired (e.g., when at the scanner), but calls to those functions can also be avoided when desired (by calling &lt;code>makeEyeLinkFcn('none')&lt;/code> instead of &lt;code>makeEyeLinkFcn('T60')&lt;/code>).&lt;/p>
&lt;pre class="matlab">&lt;code>
% ...
eyetrackerFcn = makeEyelinkFcn(input.tracker);
eyetrackerFcn(&amp;#39;message&amp;#39;, &amp;#39;SYNCTIME&amp;#39;);
% ...
&lt;/code>&lt;/pre>
&lt;p>So long as input.tracker is taking different values, there’s no need to comment or uncomment when I’m working on a computer that has or doesn’t have an eyelink hooked up&lt;a href="#fn3" class="footnote-ref" id="fnref3">&lt;sup>3&lt;/sup>&lt;/a>.&lt;/p>
&lt;p>The remainder of this script defines the local function &lt;code>T60&lt;/code>, which allows all of the necessary wrapping to the different &lt;code>Eyelink(...)&lt;/code> commands.&lt;/p>
&lt;pre class="matlab">&lt;code>
function eyelinkFcn = makeEyelinkFcn(handlerName)
valid_types = {&amp;#39;none&amp;#39;,&amp;#39;T60&amp;#39;};
assert(ismember(handlerName, valid_types),...
[&amp;#39;&amp;quot;handlerType&amp;quot; argument must be one of the following: &amp;#39; strjoin(valid_types,&amp;#39;, &amp;#39;)])
switch handlerName
case &amp;#39;T60&amp;#39;
eyelinkFcn = @T60;
case &amp;#39;none&amp;#39;
eyelinkFcn = @do_nothing;
end
function status = T60(varargin)
status = [];
switch varargin{1}
case &amp;#39;EyelinkDoDriftCorrection&amp;#39;
% Do a drift correction at the beginning of each trial
% Performing drift correction (checking) is optional for
% EyeLink 1000 eye trackers.
EyelinkDoDriftCorrection(varargin{2},[],[],0);
case &amp;#39;Command&amp;#39;
Eyelink(&amp;#39;Command&amp;#39;, varargin{2})
case &amp;#39;ImageTransfer&amp;#39;
%transfer image to host
transferimginfo = imfinfo(varargin{2});
[width, height] = Screen(&amp;#39;WindowSize&amp;#39;, 0);
% image file should be 24bit or 32bit b5itmap
% parameters of ImageTransfer:
% imagePath, xPosition, yPosition, width, height, trackerXPosition, trackerYPosition, xferoptions
transferStatus = Eyelink(&amp;#39;ImageTransfer&amp;#39;,transferimginfo.Filename,...
0, 0, transferimginfo.Width, transferimginfo.Height, ...
width/2-transferimginfo.Width/2 ,height/2-transferimginfo.Height/2, 1);
if transferStatus ~= 0
fprintf(&amp;#39;*****Image transfer Failed*****-------\n&amp;#39;);
end
case &amp;#39;StartRecording&amp;#39;
Eyelink(&amp;#39;StartRecording&amp;#39;);
case &amp;#39;Message&amp;#39;
if nargin == 2
Eyelink(&amp;#39;Message&amp;#39;, varargin{2});
elseif nargin == 3
Eyelink(&amp;#39;Message&amp;#39;, varargin{2}, varargin{3});
elseif nargin == 4
Eyelink(&amp;#39;Message&amp;#39;, varargin{2}, varargin{3}, varargin{4});
end
case &amp;#39;StopRecording&amp;#39;
Eyelink(&amp;#39;StopRecording&amp;#39;);
case &amp;#39;CloseFile&amp;#39;
Eyelink(&amp;#39;CloseFile&amp;#39;);
case &amp;#39;ReceiveFile&amp;#39;
Eyelink(&amp;#39;ReceiveFile&amp;#39;);
case &amp;#39;EyeAvailable&amp;#39;
status = Eyelink(&amp;#39;EyeAvailable&amp;#39;);
end
end
function do_nothing(varargin)
% do nothing with arguments
end
end
&lt;/code>&lt;/pre>
&lt;/div>
&lt;div id="extra-resourcess" class="section level1">
&lt;h1>Extra Resourcess&lt;/h1>
&lt;p>For examples of these methods in action, check out &lt;a href="https://github.com/psadil/VTF">an experiment on Voxel Tuning Functions&lt;/a>. In particular, see &lt;a href="https://github.com/psadil/VTF/blob/master/lib/PsychSetup/setupEyeTracker.m">setupEyeTracker&lt;/a>, &lt;a href="https://github.com/psadil/VTF/blob/master/lib/PsychEyelink/makeEyelinkFcn.m">makeEyelinkFcn&lt;/a>. That repository also has examples of using the value returned by &lt;code>makeEyelinkFcn&lt;/code> in &lt;a href="https://github.com/psadil/VTF/blob/master/lib/PsychTasks/runContrast.m">runContrast&lt;/a>. Note that the repository may change from time to time and might not match the code in this post exactly. To download the exact files defined above, see &lt;a href="https://psadil.github.io/psadil/files/matlab/setupEyeTracker.m">setupEyeTracker&lt;/a>, &lt;a href="https://psadil.github.io/psadil/files/matlab/makeEyelinkFcn.m">makeEyelinkFcn&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://link.springer.com/article/10.3758/BF03195489">Here’s the original publication&lt;/a> that introduced the Eyelink interface to PTB.&lt;/p>
&lt;p>Also, for inspiration about the cool experiments that can be run with Eyelink’s software, see the &lt;a href="https://github.com/kleinerm/Psychtoolbox-3/tree/master/Psychtoolbox/PsychHardware/EyelinkToolbox/EyelinkDemos">PTB Demos&lt;/a>. See a list of &lt;code>Eyelink&lt;/code> functions &lt;a href="http://psychtoolbox.org/docs/EyelinkToolbox">here&lt;/a>. You’ll need to look at this page if you want access to the help files for these commands on a computer without Eyelink installed.&lt;/p>
&lt;p>Finally, thanks to &lt;a href="https://www.umass.edu/pbs/people/ramiro-reyes">Ramiro&lt;/a> for sharing a PTB script that got me started with Eyelink.&lt;/p>
&lt;/div>
&lt;div class="footnotes">
&lt;hr />
&lt;ol>
&lt;li id="fn1">&lt;p>though, I’ve already broken some of the logic I outline in that section by having more than one function with a switch statement.&lt;a href="#fnref1" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn2">&lt;p>The options relating to saving data are for another post. It seems like you can do quite a lot with the Eyelink Data Viewer when various event tags have been set up properly (see &lt;a href="https://umass.box.com/s/n8ki3br7watw2niuangxxflj6ulpk67q">manual, on box&lt;/a> ), but my needs are so simple that I haven’t bothered digging too deeply.&lt;a href="#fnref2" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn3">&lt;p>Of course, a similar effect could be achieved by littering the experimental code with a bunch of &lt;code>if then else&lt;/code> statements. However, this method has the advantage of massively reducing the number of switch statements in the code. Fewer switch statements can be easier to follow and modify, because most of the effect of the &lt;code>input.tracker&lt;/code> variable can be localized to a single function (the definition of &lt;code>makeEyelinkFcn&lt;/code>)&lt;a href="#fnref3" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>